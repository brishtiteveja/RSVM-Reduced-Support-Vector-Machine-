#include <time.h>					      <
#include <sys/times.h>					      <
							      <
#include <math.h>						#include <math.h>
#include <stdio.h>						#include <stdio.h>
#include <stdlib.h>						#include <stdlib.h>
#include <ctype.h>						#include <ctype.h>
#include <float.h>						#include <float.h>
#include <string.h>						#include <string.h>
#include <stdarg.h>						#include <stdarg.h>
							      >	#include <limits.h>
							      >	#include <locale.h>
#include "svm.h"						#include "svm.h"
							      |	int libsvm_version = LIBSVM_VERSION;
/* LEVEL 2 BLAS */					      <
#ifdef __cplusplus					      <
extern "C" {						      <
#endif							      <
int dtrsv_(char *, char *, char *, int *, double *, int *, do <
int dpotf2_(char *, int *, double *, int *, int *);	      <
int dgemv_(char *trans, int *m, int *n, double *alpha, double <
           int *lda, double *x, int *incx, double *beta, doub <
           int *incy);					      <
int dscal_(int *n, double *sa, double *sx, int *incx);	      <
int daxpy_(int *n, double *sa, double *sx, int *incx, double  <
           int *incy);					      <
int dsysv_(char *, int *, int *, double *, int *, int *, doub <
           double *, int *, int *, int);		      <
							      <
							      <
extern void solvebqp(struct BQP*, double);		      <
//extern void solvebqp1(struct BQP*);			      <
							      <
#ifdef __cplusplus					      <
}							      <
							      <
#endif							      <
							      <
int mytime;						      <
							      <
typedef float Qfloat;						typedef float Qfloat;
typedef signed char schar;					typedef signed char schar;
#ifndef min							#ifndef min
template <class T> inline T min(T x,T y) { return (x<y)?x:y;  |	template <class T> static inline T min(T x,T y) { return (x<y
#endif								#endif
#ifndef max							#ifndef max
template <class T> inline T max(T x,T y) { return (x>y)?x:y;  |	template <class T> static inline T max(T x,T y) { return (x>y
#endif								#endif
template <class T> inline void swap(T& x, T& y) { T t=x; x=y; |	template <class T> static inline void swap(T& x, T& y) { T t=
template <class S, class T> inline void clone(T*& dst, S* src |	template <class S, class T> static inline void clone(T*& dst,
{								{
	dst = new T[n];							dst = new T[n];
	memcpy((void *)dst,(void *)src,sizeof(T)*n);			memcpy((void *)dst,(void *)src,sizeof(T)*n);
}								}
							      >	static inline double powi(double base, int times)
							      >	{
							      >		double tmp = base, ret = 1.0;
							      >
							      >		for(int t=times; t>0; t/=2)
							      >		{
							      >			if(t%2==1) ret*=tmp;
							      >			tmp = tmp * tmp;
							      >		}
							      >		return ret;
							      >	}
#define INF HUGE_VAL						#define INF HUGE_VAL
							      >	#define TAU 1e-12
#define Malloc(type,n) (type *)malloc((n)*sizeof(type))		#define Malloc(type,n) (type *)malloc((n)*sizeof(type))
							      >
							      >	static void print_string_stdout(const char *s)
							      >	{
							      >		fputs(s,stdout);
							      >		fflush(stdout);
							      >	}
							      >	static void (*svm_print_string) (const char *) = &print_strin
#if 1								#if 1
void info(char *fmt,...)				      |	static void info(const char *fmt,...)
{								{
							      >		char buf[BUFSIZ];
	va_list ap;							va_list ap;
	va_start(ap,fmt);						va_start(ap,fmt);
	vprintf(fmt,ap);				      |		vsprintf(buf,fmt,ap);
	va_end(ap);							va_end(ap);
}							      |		(*svm_print_string)(buf);
void info_flush()					      <
{							      <
	fflush(stdout);					      <
}								}
#else								#else
void info(char *fmt,...) {}				      |	static void info(const char *fmt,...) {}
void info_flush() {}					      <
#endif								#endif

//								//
// Kernel Cache							// Kernel Cache
//								//
// l is the number of total data items				// l is the number of total data items
// size is the cache size limit in bytes			// size is the cache size limit in bytes
//								//
class Cache							class Cache
{								{
public:								public:
	Cache(int l,int size);				      |		Cache(int l,long int size);
	~Cache();							~Cache();

	// request data [0,len)						// request data [0,len)
	// return some position p where [p,len) need to be fi		// return some position p where [p,len) need to be fi
	// (p >= len if nothing needs to be filled)			// (p >= len if nothing needs to be filled)
	int get_data(const int index, Qfloat **data, int len)		int get_data(const int index, Qfloat **data, int len)
	void swap_index(int i, int j);	// future_option      |		void swap_index(int i, int j);
private:							private:
	int l;								int l;
	int size;					      |		long int size;
	struct head_t							struct head_t
	{								{
		head_t *prev, *next;	// a cicular list     |			head_t *prev, *next;	// a circular list
		Qfloat *data;							Qfloat *data;
		int len;		// data[0,len) is cac			int len;		// data[0,len) is cac
	};								};

	head_t* head;					      |		head_t *head;
	head_t lru_head;						head_t lru_head;
	void lru_delete(head_t *h);					void lru_delete(head_t *h);
	void lru_insert(head_t *h);					void lru_insert(head_t *h);
};								};

Cache::Cache(int l_,int size_):l(l_),size(size_)	      |	Cache::Cache(int l_,long int size_):l(l_),size(size_)
{								{
	head = (head_t *)calloc(l,sizeof(head_t));	// in		head = (head_t *)calloc(l,sizeof(head_t));	// in
	size /= sizeof(Qfloat);						size /= sizeof(Qfloat);
	size -= l * sizeof(head_t) / sizeof(Qfloat);			size -= l * sizeof(head_t) / sizeof(Qfloat);
							      >		size = max(size, 2 * (long int) l);	// cache must
	lru_head.next = lru_head.prev = &lru_head;			lru_head.next = lru_head.prev = &lru_head;
}								}

Cache::~Cache()							Cache::~Cache()
{								{
	for(head_t *h = lru_head.next; h != &lru_head; h=h->n		for(head_t *h = lru_head.next; h != &lru_head; h=h->n
		free(h->data);							free(h->data);
	free(head);							free(head);
}								}

void Cache::lru_delete(head_t *h)				void Cache::lru_delete(head_t *h)
{								{
	// delete from current location					// delete from current location
	h->prev->next = h->next;					h->prev->next = h->next;
	h->next->prev = h->prev;					h->next->prev = h->prev;
}								}

void Cache::lru_insert(head_t *h)				void Cache::lru_insert(head_t *h)
{								{
	// insert to last position					// insert to last position
	h->next = &lru_head;						h->next = &lru_head;
	h->prev = lru_head.prev;					h->prev = lru_head.prev;
	h->prev->next = h;						h->prev->next = h;
	h->next->prev = h;						h->next->prev = h;
}								}

int Cache::get_data(const int index, Qfloat **data, int len)	int Cache::get_data(const int index, Qfloat **data, int len)
{								{
	head_t *h = &head[index];					head_t *h = &head[index];
	if(h->len) lru_delete(h);					if(h->len) lru_delete(h);
	int more = len - h->len;					int more = len - h->len;

	if(more > 0)							if(more > 0)
	{								{
		// free old space						// free old space
		while(size < more)						while(size < more)
		{								{
			head_t *old = lru_head.next;					head_t *old = lru_head.next;
			lru_delete(old);						lru_delete(old);
			free(old->data);						free(old->data);
			size += old->len;						size += old->len;
			old->data = 0;							old->data = 0;
			old->len = 0;							old->len = 0;
		}								}

		// allocate new space						// allocate new space
		h->data = (Qfloat *)realloc(h->data,sizeof(Qf			h->data = (Qfloat *)realloc(h->data,sizeof(Qf
		size -= more;							size -= more;
		swap(h->len,len);						swap(h->len,len);
	}								}

	lru_insert(h);							lru_insert(h);
	*data = h->data;						*data = h->data;
	return len;							return len;
}								}

void Cache::swap_index(int i, int j)				void Cache::swap_index(int i, int j)
{								{
	if(i==j) return;						if(i==j) return;

	if(head[i].len) lru_delete(&head[i]);				if(head[i].len) lru_delete(&head[i]);
	if(head[j].len) lru_delete(&head[j]);				if(head[j].len) lru_delete(&head[j]);
	swap(head[i].data,head[j].data);				swap(head[i].data,head[j].data);
	swap(head[i].len,head[j].len);					swap(head[i].len,head[j].len);
	if(head[i].len) lru_insert(&head[i]);				if(head[i].len) lru_insert(&head[i]);
	if(head[j].len) lru_insert(&head[j]);				if(head[j].len) lru_insert(&head[j]);

	if(i>j) swap(i,j);						if(i>j) swap(i,j);
	for(head_t *h = lru_head.next; h!=&lru_head; h=h->nex		for(head_t *h = lru_head.next; h!=&lru_head; h=h->nex
	{								{
		if(h->len > i)							if(h->len > i)
		{								{
			if(h->len > j)							if(h->len > j)
				swap(h->data[i],h->data[j]);					swap(h->data[i],h->data[j]);
			else								else
			{								{
				// give up							// give up
				lru_delete(h);							lru_delete(h);
				free(h->data);							free(h->data);
				size += h->len;							size += h->len;
				h->data = 0;							h->data = 0;
				h->len = 0;							h->len = 0;
			}								}
		}								}
	}								}
}								}

//								//
// Kernel evaluation						// Kernel evaluation
//								//
// the static method k_function is for doing single kernel ev	// the static method k_function is for doing single kernel ev
// the constructor of Kernel prepares to calculate the l*l ke	// the constructor of Kernel prepares to calculate the l*l ke
// the member function get_Q is for getting one column from t	// the member function get_Q is for getting one column from t
//								//
class Kernel {						      |	class QMatrix {
public:								public:
	Kernel(int l, const svm_node * const * x, const svm_p |		virtual Qfloat *get_Q(int column, int len) const = 0;
							      >		virtual double *get_QD() const = 0;
							      >		virtual void swap_index(int i, int j) const = 0;
							      >		virtual ~QMatrix() {}
							      >	};
							      >
							      >	class Kernel: public QMatrix {
							      >	public:
							      >		Kernel(int l, svm_node * const * x, const svm_paramet
	virtual ~Kernel();						virtual ~Kernel();

	static double k_function(const svm_node *x, const svm		static double k_function(const svm_node *x, const svm
				 const svm_parameter& param);					 const svm_parameter& param);
	virtual Qfloat *get_Q(int column, int len) const = 0;		virtual Qfloat *get_Q(int column, int len) const = 0;
							      >		virtual double *get_QD() const = 0;
	virtual void swap_index(int i, int j) const	// no		virtual void swap_index(int i, int j) const	// no
	{								{
		swap(x[i],x[j]);						swap(x[i],x[j]);
		if(x_square) swap(x_square[i],x_square[j]);			if(x_square) swap(x_square[i],x_square[j]);
	}								}
protected:							protected:

	double (Kernel::*kernel_function)(int i, int j) const		double (Kernel::*kernel_function)(int i, int j) const

private:							private:
	const svm_node **x;						const svm_node **x;
	double *x_square;						double *x_square;

	// svm_parameter						// svm_parameter
	const int kernel_type;						const int kernel_type;
	const double degree;				      |		const int degree;
	const double gamma;						const double gamma;
	const double coef0;						const double coef0;

     	static double dot(const svm_node *px, const svm_node  |		static double dot(const svm_node *px, const svm_node 
	double kernel_linear(int i, int j) const			double kernel_linear(int i, int j) const
	{								{
		return dot(x[i],x[j]);						return dot(x[i],x[j]);
	}								}
	double kernel_poly(int i, int j) const				double kernel_poly(int i, int j) const
	{								{
		return pow(gamma*dot(x[i],x[j])+coef0,degree) |			return powi(gamma*dot(x[i],x[j])+coef0,degree
	}								}
	double kernel_rbf(int i, int j) const				double kernel_rbf(int i, int j) const
	{								{
		return exp(-gamma*(x_square[i]+x_square[j]-2*			return exp(-gamma*(x_square[i]+x_square[j]-2*
	}								}
	double kernel_sigmoid(int i, int j) const			double kernel_sigmoid(int i, int j) const
	{								{
		return tanh(gamma*dot(x[i],x[j])+coef0);			return tanh(gamma*dot(x[i],x[j])+coef0);
	}								}
							      >		double kernel_precomputed(int i, int j) const
							      >		{
							      >			return x[i][(int)(x[j][0].value)].value;
							      >		}
};								};

Kernel::Kernel(int l, const svm_node * const * x_, const svm_ |	Kernel::Kernel(int l, svm_node * const * x_, const svm_parame
:kernel_type(param.kernel_type), degree(param.degree),		:kernel_type(param.kernel_type), degree(param.degree),
 gamma(param.gamma), coef0(param.coef0)				 gamma(param.gamma), coef0(param.coef0)
{								{
	switch(kernel_type)						switch(kernel_type)
	{								{
		case LINEAR:							case LINEAR:
			kernel_function = &Kernel::kernel_lin				kernel_function = &Kernel::kernel_lin
			break;								break;
		case POLY:							case POLY:
			kernel_function = &Kernel::kernel_pol				kernel_function = &Kernel::kernel_pol
			break;								break;
		case RBF:							case RBF:
			kernel_function = &Kernel::kernel_rbf				kernel_function = &Kernel::kernel_rbf
			break;								break;
		case SIGMOID:							case SIGMOID:
			kernel_function = &Kernel::kernel_sig				kernel_function = &Kernel::kernel_sig
			break;								break;
		default:				      |			case PRECOMPUTED:
			fprintf(stderr,"unknown kernel functi |				kernel_function = &Kernel::kernel_pre
			exit(1);			      |				break;
	}								}

	clone(x,x_,l);							clone(x,x_,l);

	if(kernel_type == RBF)						if(kernel_type == RBF)
	{								{
		x_square = new double[l];					x_square = new double[l];
		for(int i=0;i<l;i++)						for(int i=0;i<l;i++)
			x_square[i] = dot(x[i],x[i]);					x_square[i] = dot(x[i],x[i]);
	}								}
	else								else
		x_square = 0;							x_square = 0;
}								}

Kernel::~Kernel()						Kernel::~Kernel()
{								{
	delete[] x;							delete[] x;
	delete[] x_square;						delete[] x_square;
}								}

double Kernel::dot(const svm_node *px, const svm_node *py)	double Kernel::dot(const svm_node *px, const svm_node *py)
{								{
	double sum = 0;							double sum = 0;
	while(px->index != -1 && py->index != -1)			while(px->index != -1 && py->index != -1)
	{								{
		if(px->index == py->index)					if(px->index == py->index)
		{								{
			sum += px->value * py->value;					sum += px->value * py->value;
			++px;								++px;
			++py;								++py;
		}								}
		else								else
		{								{
			if(px->index > py->index)					if(px->index > py->index)
				++py;								++py;
			else								else
				++px;								++px;
		}								}			
	}								}
	return sum;							return sum;
}								}

double Kernel::k_function(const svm_node *x, const svm_node *	double Kernel::k_function(const svm_node *x, const svm_node *
			  const svm_parameter& param)					  const svm_parameter& param)
{								{
	switch(param.kernel_type)					switch(param.kernel_type)
	{								{
		case LINEAR:							case LINEAR:
			return dot(x,y);						return dot(x,y);
		case POLY:							case POLY:
			return pow(param.gamma*dot(x,y)+param |				return powi(param.gamma*dot(x,y)+para
		case RBF:							case RBF:
		{								{
			double sum = 0;							double sum = 0;
			while(x->index != -1 && y->index !=-1				while(x->index != -1 && y->index !=-1
			{								{
				if(x->index == y->index)					if(x->index == y->index)
				{								{
					double d = x->value -						double d = x->value -
					sum += d*d;							sum += d*d;
					++x;								++x;
					++y;								++y;
				}								}
				else								else
				{								{
					if(x->index > y->inde						if(x->index > y->inde
					{								{	
						sum += y->val							sum += y->val
						++y;								++y;
					}								}
					else								else
					{								{
						sum += x->val							sum += x->val
						++x;								++x;
					}								}
				}								}
			}								}

			while(x->index != -1)						while(x->index != -1)
			{								{
				sum += x->value * x->value;					sum += x->value * x->value;
				++x;								++x;
			}								}

			while(y->index != -1)						while(y->index != -1)
			{								{
				sum += y->value * y->value;					sum += y->value * y->value;
				++y;								++y;
			}								}
											
			return exp(-param.gamma*sum);					return exp(-param.gamma*sum);
		}								}
		case SIGMOID:							case SIGMOID:
			return tanh(param.gamma*dot(x,y)+para				return tanh(param.gamma*dot(x,y)+para
							      >			case PRECOMPUTED:  //x: test (validation), y:
							      >				return x[(int)(y->value)].value;
		default:							default:
			break;				      |				return 0;  // Unreachable 
	}								}
	fprintf(stderr,"unknown kernel function.\n");	      <
	exit(1);					      <
}								}

// Generalized SMO+SVMlight algorithm			      |	// An SMO algorithm in Fan et al., JMLR 6(2005), p. 1889--191
// Solves:							// Solves:
//								//
//	min 0.5(\alpha^T Q \alpha) + b^T \alpha		      |	//	min 0.5(\alpha^T Q \alpha) + p^T \alpha
//								//
//		y^T \alpha = \delta				//		y^T \alpha = \delta
//		y_i = +1 or -1					//		y_i = +1 or -1
//		0 <= alpha_i <= Cp for y_i = 1			//		0 <= alpha_i <= Cp for y_i = 1
//		0 <= alpha_i <= Cn for y_i = -1			//		0 <= alpha_i <= Cn for y_i = -1
//								//
// Given:							// Given:
//								//
//	Q, b, y, Cp, Cn, and an initial feasible point \alpha |	//	Q, p, y, Cp, Cn, and an initial feasible point \alpha
//	l is the size of vectors and matrices			//	l is the size of vectors and matrices
//	eps is the stopping criterion			      |	//	eps is the stopping tolerance
//								//
// solution will be put in \alpha, objective value will be pu	// solution will be put in \alpha, objective value will be pu
//								//
class Solver {							class Solver {
public:								public:
	Solver() {};							Solver() {};
	virtual ~Solver() {};						virtual ~Solver() {};

	struct SolutionInfo {						struct SolutionInfo {
		double obj;							double obj;
		double rho;							double rho;
		double upper_bound_p;						double upper_bound_p;
		double upper_bound_n;						double upper_bound_n;
		double r;	// for Solver_NU				double r;	// for Solver_NU
	};								};

	void Solve(int l, const Kernel& Q, const double *b_,  |		void Solve(int l, const QMatrix& Q, const double *p_,
		   double *alpha_, double Cp, double Cn, doub			   double *alpha_, double Cp, double Cn, doub
		   SolutionInfo* si, int shrinking);				   SolutionInfo* si, int shrinking);
protected:							protected:
	int active_size;						int active_size;
	schar *y;							schar *y;
	double *G;		// gradient of objective func		double *G;		// gradient of objective func
	enum { LOWER_BOUND, UPPER_BOUND, FREE };			enum { LOWER_BOUND, UPPER_BOUND, FREE };
	char *alpha_status;	// LOWER_BOUND, UPPER_BOUND, 		char *alpha_status;	// LOWER_BOUND, UPPER_BOUND, 
	double *alpha;							double *alpha;
	const Kernel *Q;				      |		const QMatrix *Q;
							      >		const double *QD;
	double eps;							double eps;
	double Cp,Cn;							double Cp,Cn;
	double *b;					      |		double *p;
	int *active_set;						int *active_set;
	double *G_bar;		// gradient, if we treat free		double *G_bar;		// gradient, if we treat free
	int l;								int l;
	bool unshrinked;	// XXX			      |		bool unshrink;	// XXX

	double get_C(int i)						double get_C(int i)
	{								{
		return (y[i] > 0)? Cp : Cn;					return (y[i] > 0)? Cp : Cn;
	}								}
	void update_alpha_status(int i)					void update_alpha_status(int i)
	{								{
		if(alpha[i] >= get_C(i))					if(alpha[i] >= get_C(i))
			alpha_status[i] = UPPER_BOUND;					alpha_status[i] = UPPER_BOUND;
		else if(alpha[i] <= 0)						else if(alpha[i] <= 0)
			alpha_status[i] = LOWER_BOUND;					alpha_status[i] = LOWER_BOUND;
		else alpha_status[i] = FREE;					else alpha_status[i] = FREE;
	}								}
	bool is_upper_bound(int i) { return alpha_status[i] =		bool is_upper_bound(int i) { return alpha_status[i] =
	bool is_lower_bound(int i) { return alpha_status[i] =		bool is_lower_bound(int i) { return alpha_status[i] =
	bool is_free(int i) { return alpha_status[i] == FREE;		bool is_free(int i) { return alpha_status[i] == FREE;
	void swap_index(int i, int j);					void swap_index(int i, int j);
	void reconstruct_gradient();					void reconstruct_gradient();
	virtual int select_working_set(int &i, int &j);			virtual int select_working_set(int &i, int &j);
	virtual double calculate_rho();					virtual double calculate_rho();
	virtual void do_shrinking();					virtual void do_shrinking();
							      >	private:
							      >		bool be_shrunk(int i, double Gmax1, double Gmax2);
};								};

void Solver::swap_index(int i, int j)				void Solver::swap_index(int i, int j)
{								{
	Q->swap_index(i,j);						Q->swap_index(i,j);
	swap(y[i],y[j]);						swap(y[i],y[j]);
	swap(G[i],G[j]);						swap(G[i],G[j]);
	swap(alpha_status[i],alpha_status[j]);				swap(alpha_status[i],alpha_status[j]);
	swap(alpha[i],alpha[j]);					swap(alpha[i],alpha[j]);
	swap(b[i],b[j]);				      |		swap(p[i],p[j]);
	swap(active_set[i],active_set[j]);				swap(active_set[i],active_set[j]);
	swap(G_bar[i],G_bar[j]);					swap(G_bar[i],G_bar[j]);
}								}

void Solver::reconstruct_gradient()				void Solver::reconstruct_gradient()
{								{
	// reconstruct inactive elements of G from G_bar and 		// reconstruct inactive elements of G from G_bar and 

	if(active_size == l) return;					if(active_size == l) return;

	int i;						      |		int i,j;
	for(i=active_size;i<l;i++)			      |		int nr_free = 0;
		G[i] = G_bar[i] + b[i];			      |
							      |		for(j=active_size;j<l;j++)
	for(i=0;i<active_size;i++)			      |			G[j] = G_bar[j] + p[j];
		if(is_free(i))				      |
							      >		for(j=0;j<active_size;j++)
							      >			if(is_free(j))
							      >				nr_free++;
							      >
							      >		if(2*nr_free < active_size)
							      >			info("\nWARNING: using -h 0 may be faster\n")
							      >
							      >		if (nr_free*l > 2*active_size*(l-active_size))
							      >		{
							      >			for(i=active_size;i<l;i++)
		{								{
			const Qfloat *Q_i = Q->get_Q(i,l);    |				const Qfloat *Q_i = Q->get_Q(i,active
			double alpha_i = alpha[i];	      |				for(j=0;j<active_size;j++)
			for(int j=active_size;j<l;j++)	      |					if(is_free(j))
				G[j] += alpha_i * Q_i[j];     |						G[i] += alpha[j] * Q_
		}								}
							      >		}
							      >		else
							      >		{
							      >			for(i=0;i<active_size;i++)
							      >				if(is_free(i))
							      >				{
							      >					const Qfloat *Q_i = Q->get_Q(
							      >					double alpha_i = alpha[i];
							      >					for(j=active_size;j<l;j++)
							      >						G[j] += alpha_i * Q_i
							      >				}
							      >		}
}								}

void Solver::Solve(int l, const Kernel& Q, const double *b_,  |	void Solver::Solve(int l, const QMatrix& Q, const double *p_,
		   double *alpha_, double Cp, double Cn, doub			   double *alpha_, double Cp, double Cn, doub
		   SolutionInfo* si, int shrinking)				   SolutionInfo* si, int shrinking)
{								{
	this->l = l;							this->l = l;
	this->Q = &Q;							this->Q = &Q;
	clone(b, b_,l);					      |		QD=Q.get_QD();
							      >		clone(p, p_,l);
	clone(y, y_,l);							clone(y, y_,l);
	clone(alpha,alpha_,l);						clone(alpha,alpha_,l);
	this->Cp = Cp;							this->Cp = Cp;
	this->Cn = Cn;							this->Cn = Cn;
	this->eps = eps;						this->eps = eps;
	unshrinked = false;				      |		unshrink = false;

	// initialize alpha_status					// initialize alpha_status
	{								{
		alpha_status = new char[l];					alpha_status = new char[l];
		for(int i=0;i<l;i++)						for(int i=0;i<l;i++)
			update_alpha_status(i);						update_alpha_status(i);
	}								}

	// initialize active set (for shrinking)			// initialize active set (for shrinking)
	{								{
		active_set = new int[l];					active_set = new int[l];
		for(int i=0;i<l;i++)						for(int i=0;i<l;i++)
			active_set[i] = i;						active_set[i] = i;
		active_size = l;						active_size = l;
	}								}

	// initialize gradient						// initialize gradient
	{								{
		G = new double[l];						G = new double[l];
		G_bar = new double[l];						G_bar = new double[l];
		int i;								int i;
		for(i=0;i<l;i++)						for(i=0;i<l;i++)
		{								{
			G[i] = b[i];			      |				G[i] = p[i];
			G_bar[i] = 0;							G_bar[i] = 0;
		}								}
		for(i=0;i<l;i++)						for(i=0;i<l;i++)
			if(!is_lower_bound(i))						if(!is_lower_bound(i))
			{								{
				Qfloat *Q_i = Q.get_Q(i,l);   |					const Qfloat *Q_i = Q.get_Q(i
				double alpha_i = alpha[i];					double alpha_i = alpha[i];
				int j;								int j;
				for(j=0;j<l;j++)						for(j=0;j<l;j++)
					G[j] += alpha_i*Q_i[j						G[j] += alpha_i*Q_i[j
				if(is_upper_bound(i))						if(is_upper_bound(i))
					for(j=0;j<l;j++)						for(j=0;j<l;j++)
						G_bar[j] += g							G_bar[j] += g
			}								}
	}								}

	// optimization step						// optimization step

	int iter = 0;							int iter = 0;
							      >		int max_iter = max(10000000, l>INT_MAX/100 ? INT_MAX 
	int counter = min(l,1000)+1;					int counter = min(l,1000)+1;
							      |		
	while(1)					      |		while(iter < max_iter)
	{								{
		// show progress and do shrinking				// show progress and do shrinking

		if(--counter == 0)						if(--counter == 0)
		{								{
			counter = min(l,1000);						counter = min(l,1000);
			if(shrinking) do_shrinking();					if(shrinking) do_shrinking();
			info("."); info_flush();	      |				info(".");
		}								}

		int i,j;							int i,j;
		if(select_working_set(i,j)!=0)					if(select_working_set(i,j)!=0)
		{								{
			// reconstruct the whole gradient				// reconstruct the whole gradient
			reconstruct_gradient();						reconstruct_gradient();
			// reset active set size and check				// reset active set size and check
			active_size = l;						active_size = l;
			info("*"); info_flush();	      |				info("*");
			if(select_working_set(i,j)!=0)					if(select_working_set(i,j)!=0)
				break;								break;
			else								else
				counter = 1;	// do shrinki					counter = 1;	// do shrinki
		}								}
										
		++iter;								++iter;

		// update alpha[i] and alpha[j], handle bound			// update alpha[i] and alpha[j], handle bound
										
		const Qfloat *Q_i = Q.get_Q(i,active_size);			const Qfloat *Q_i = Q.get_Q(i,active_size);
		const Qfloat *Q_j = Q.get_Q(j,active_size);			const Qfloat *Q_j = Q.get_Q(j,active_size);

		double C_i = get_C(i);						double C_i = get_C(i);
		double C_j = get_C(j);						double C_j = get_C(j);

		double old_alpha_i = alpha[i];					double old_alpha_i = alpha[i];
		double old_alpha_j = alpha[j];					double old_alpha_j = alpha[j];

		if(y[i]!=y[j])							if(y[i]!=y[j])
		{								{
			double delta = (-G[i]-G[j])/(Q_i[i]+Q |				double quad_coef = QD[i]+QD[j]+2*Q_i[
							      >				if (quad_coef <= 0)
							      >					quad_coef = TAU;
							      >				double delta = (-G[i]-G[j])/quad_coef
			double diff = alpha[i] - alpha[j];				double diff = alpha[i] - alpha[j];
			alpha[i] += delta;						alpha[i] += delta;
			alpha[j] += delta;						alpha[j] += delta;
											
			if(diff > 0)							if(diff > 0)
			{								{
				if(alpha[j] < 0)						if(alpha[j] < 0)
				{								{
					alpha[j] = 0;							alpha[j] = 0;
					alpha[i] = diff;						alpha[i] = diff;
				}								}
			}								}
			else								else
			{								{
				if(alpha[i] < 0)						if(alpha[i] < 0)
				{								{
					alpha[i] = 0;							alpha[i] = 0;
					alpha[j] = -diff;						alpha[j] = -diff;
				}								}
			}								}
			if(diff > C_i - C_j)						if(diff > C_i - C_j)
			{								{
				if(alpha[i] > C_i)						if(alpha[i] > C_i)
				{								{
					alpha[i] = C_i;							alpha[i] = C_i;
					alpha[j] = C_i - diff						alpha[j] = C_i - diff
				}								}
			}								}
			else								else
			{								{
				if(alpha[j] > C_j)						if(alpha[j] > C_j)
				{								{
					alpha[j] = C_j;							alpha[j] = C_j;
					alpha[i] = C_j + diff						alpha[i] = C_j + diff
				}								}
			}								}
		}								}
		else								else
		{								{
			double delta = (G[i]-G[j])/(Q_i[i]+Q_ |				double quad_coef = QD[i]+QD[j]-2*Q_i[
							      >				if (quad_coef <= 0)
							      >					quad_coef = TAU;
							      >				double delta = (G[i]-G[j])/quad_coef;
			double sum = alpha[i] + alpha[j];				double sum = alpha[i] + alpha[j];
			alpha[i] -= delta;						alpha[i] -= delta;
			alpha[j] += delta;						alpha[j] += delta;
							      >
			if(sum > C_i)							if(sum > C_i)
			{								{
				if(alpha[i] > C_i)						if(alpha[i] > C_i)
				{								{
					alpha[i] = C_i;							alpha[i] = C_i;
					alpha[j] = sum - C_i;						alpha[j] = sum - C_i;
				}								}
			}								}
			else								else
			{								{
				if(alpha[j] < 0)						if(alpha[j] < 0)
				{								{
					alpha[j] = 0;							alpha[j] = 0;
					alpha[i] = sum;							alpha[i] = sum;
				}								}
			}								}
			if(sum > C_j)							if(sum > C_j)
			{								{
				if(alpha[j] > C_j)						if(alpha[j] > C_j)
				{								{
					alpha[j] = C_j;							alpha[j] = C_j;
					alpha[i] = sum - C_j;						alpha[i] = sum - C_j;
				}								}
			}								}
			else								else
			{								{
				if(alpha[i] < 0)						if(alpha[i] < 0)
				{								{
					alpha[i] = 0;							alpha[i] = 0;
					alpha[j] = sum;							alpha[j] = sum;
				}								}
			}								}
		}								}

		// update G							// update G

		double delta_alpha_i = alpha[i] - old_alpha_i			double delta_alpha_i = alpha[i] - old_alpha_i
		double delta_alpha_j = alpha[j] - old_alpha_j			double delta_alpha_j = alpha[j] - old_alpha_j
										
		for(int k=0;k<active_size;k++)					for(int k=0;k<active_size;k++)
		{								{
			G[k] += Q_i[k]*delta_alpha_i + Q_j[k]				G[k] += Q_i[k]*delta_alpha_i + Q_j[k]
		}								}

		// update alpha_status and G_bar				// update alpha_status and G_bar

		{								{
			bool ui = is_upper_bound(i);					bool ui = is_upper_bound(i);
			bool uj = is_upper_bound(j);					bool uj = is_upper_bound(j);
			update_alpha_status(i);						update_alpha_status(i);
			update_alpha_status(j);						update_alpha_status(j);
			int k;								int k;
			if(ui != is_upper_bound(i))					if(ui != is_upper_bound(i))
			{								{
				Q_i = Q.get_Q(i,l);						Q_i = Q.get_Q(i,l);
				if(ui)								if(ui)
					for(k=0;k<l;k++)						for(k=0;k<l;k++)
						G_bar[k] -= C							G_bar[k] -= C
				else								else
					for(k=0;k<l;k++)						for(k=0;k<l;k++)
						G_bar[k] += C							G_bar[k] += C
			}								}

			if(uj != is_upper_bound(j))					if(uj != is_upper_bound(j))
			{								{
				Q_j = Q.get_Q(j,l);						Q_j = Q.get_Q(j,l);
				if(uj)								if(uj)
					for(k=0;k<l;k++)						for(k=0;k<l;k++)
						G_bar[k] -= C							G_bar[k] -= C
				else								else
					for(k=0;k<l;k++)						for(k=0;k<l;k++)
						G_bar[k] += C							G_bar[k] += C
			}								}
		}								}
	}								}

							      >		if(iter >= max_iter)
							      >		{
							      >			if(active_size < l)
							      >			{
							      >				// reconstruct the whole gradient to 
							      >				reconstruct_gradient();
							      >				active_size = l;
							      >				info("*");
							      >			}
							      >			fprintf(stderr,"\nWARNING: reaching max numbe
							      >		}
							      >
	// calculate rho						// calculate rho

	si->rho = calculate_rho();					si->rho = calculate_rho();

	// calculate objective value					// calculate objective value
	{								{
		double v = 0;							double v = 0;
		int i;								int i;
		for(i=0;i<l;i++)						for(i=0;i<l;i++)
			v += alpha[i] * (G[i] + b[i]);	      |				v += alpha[i] * (G[i] + p[i]);

		si->obj = v/2;							si->obj = v/2;
	}								}

	// put back the solution					// put back the solution
	{								{
		for(int i=0;i<l;i++)						for(int i=0;i<l;i++)
			alpha_[active_set[i]] = alpha[i];				alpha_[active_set[i]] = alpha[i];
	}								}

	// juggle everything back					// juggle everything back
	/*{								/*{
		for(int i=0;i<l;i++)						for(int i=0;i<l;i++)
			while(active_set[i] != i)					while(active_set[i] != i)
				swap_index(i,active_set[i]);					swap_index(i,active_set[i]);
				// or Q.swap_index(i,active_s					// or Q.swap_index(i,active_s
	}*/								}*/

	si->upper_bound_p = Cp;						si->upper_bound_p = Cp;
	si->upper_bound_n = Cn;						si->upper_bound_n = Cn;

	info("\noptimization finished, #iter = %d\n",iter);		info("\noptimization finished, #iter = %d\n",iter);

	delete[] b;					      |		delete[] p;
	delete[] y;							delete[] y;
	delete[] alpha;							delete[] alpha;
	delete[] alpha_status;						delete[] alpha_status;
	delete[] active_set;						delete[] active_set;
	delete[] G;							delete[] G;
	delete[] G_bar;							delete[] G_bar;
}								}

// return 1 if already optimal, return 0 otherwise		// return 1 if already optimal, return 0 otherwise
int Solver::select_working_set(int &out_i, int &out_j)		int Solver::select_working_set(int &out_i, int &out_j)
{								{
	// return i,j which maximize -grad(f)^T d , under con |		// return i,j such that
	// if alpha_i == C, d != +1			      |		// i: maximizes -y_i * grad(f)_i, i in I_up(\alpha)
	// if alpha_i == 0, d != -1			      |		// j: minimizes the decrease of obj value
							      |		//    (if quadratic coefficeint <= 0, replace it with
	double Gmax1 = -INF;		// max { -grad(f)_i * |		//    -y_j*grad(f)_j < -y_i*grad(f)_i, j in I_low(\al
	int Gmax1_idx = -1;				      |		
							      |		double Gmax = -INF;
	double Gmax2 = -INF;		// max { -grad(f)_i * |		double Gmax2 = -INF;
	int Gmax2_idx = -1;				      |		int Gmax_idx = -1;
							      >		int Gmin_idx = -1;
							      >		double obj_diff_min = INF;

	for(int i=0;i<active_size;i++)			      |		for(int t=0;t<active_size;t++)
	{						      |			if(y[t]==+1)	
		if(y[i]==+1)	// y = +1		      <
		{								{
			if(!is_upper_bound(i))	// d = +1     |				if(!is_upper_bound(t))
			{				      |					if(-G[t] >= Gmax)
				if(-G[i] > Gmax1)	      <
				{								{
					Gmax1 = -G[i];	      |						Gmax = -G[t];
					Gmax1_idx = i;	      |						Gmax_idx = t;
				}								}
			}				      |			}
			if(!is_lower_bound(i))	// d = -1     |			else
			{				      |			{
				if(G[i] > Gmax2)	      |				if(!is_lower_bound(t))
							      >					if(G[t] >= Gmax)
				{								{
					Gmax2 = G[i];	      |						Gmax = G[t];
					Gmax2_idx = i;	      |						Gmax_idx = t;
				}								}
			}				      <
		}								}
		else		// y = -1		      |
							      >		int i = Gmax_idx;
							      >		const Qfloat *Q_i = NULL;
							      >		if(i != -1) // NULL Q_i not accessed: Gmax=-INF if i=
							      >			Q_i = Q->get_Q(i,active_size);
							      >
							      >		for(int j=0;j<active_size;j++)
							      >		{
							      >			if(y[j]==+1)
		{								{
			if(!is_upper_bound(i))	// d = +1     |				if (!is_lower_bound(j))
			{								{
				if(-G[i] > Gmax2)	      |					double grad_diff=Gmax+G[j];
							      >					if (G[j] >= Gmax2)
							      >						Gmax2 = G[j];
							      >					if (grad_diff > 0)
				{								{
					Gmax2 = -G[i];	      |						double obj_diff;
					Gmax2_idx = i;	      |						double quad_coef = QD
							      >						if (quad_coef > 0)
							      >							obj_diff = -(
							      >						else
							      >							obj_diff = -(
							      >
							      >						if (obj_diff <= obj_d
							      >						{
							      >							Gmin_idx=j;
							      >							obj_diff_min 
							      >						}
				}								}
			}								}
			if(!is_lower_bound(i))	// d = -1     |			}
							      >			else
							      >			{
							      >				if (!is_upper_bound(j))
			{								{
				if(G[i] > Gmax1)	      |					double grad_diff= Gmax-G[j];
				{			      |					if (-G[j] >= Gmax2)
					Gmax1 = G[i];	      |						Gmax2 = -G[j];
					Gmax1_idx = i;	      |					if (grad_diff > 0)
							      >					{
							      >						double obj_diff;
							      >						double quad_coef = QD
							      >						if (quad_coef > 0)
							      >							obj_diff = -(
							      >						else
							      >							obj_diff = -(
							      >
							      >						if (obj_diff <= obj_d
							      >						{
							      >							Gmin_idx=j;
							      >							obj_diff_min 
							      >						}
				}								}
			}								}
		}								}
	}								}

	if(Gmax1+Gmax2 < eps)				      |		if(Gmax+Gmax2 < eps || Gmin_idx == -1)
 		return 1;				      |			return 1;

	out_i = Gmax1_idx;				      |		out_i = Gmax_idx;
	out_j = Gmax2_idx;				      |		out_j = Gmin_idx;
	return 0;							return 0;
}								}

							      >	bool Solver::be_shrunk(int i, double Gmax1, double Gmax2)
							      >	{
							      >		if(is_upper_bound(i))
							      >		{
							      >			if(y[i]==+1)
							      >				return(-G[i] > Gmax1);
							      >			else
							      >				return(-G[i] > Gmax2);
							      >		}
							      >		else if(is_lower_bound(i))
							      >		{
							      >			if(y[i]==+1)
							      >				return(G[i] > Gmax2);
							      >			else	
							      >				return(G[i] > Gmax1);
							      >		}
							      >		else
							      >			return(false);
							      >	}
							      >
void Solver::do_shrinking()					void Solver::do_shrinking()
{								{
	int i,j,k;					      |		int i;
	if(select_working_set(i,j)!=0) return;		      |		double Gmax1 = -INF;		// max { -y_i * grad(
	double Gm1 = -y[j]*G[j];			      |		double Gmax2 = -INF;		// max { y_i * grad(f
	double Gm2 = y[i]*G[i];				      <

	// shrink					      |		// find maximal violating pair first
							      |		for(i=0;i<active_size;i++)
	for(k=0;k<active_size;k++)			      <
	{								{
		if(is_lower_bound(k))			      |			if(y[i]==+1)	
		{								{
			if(y[k]==+1)			      |				if(!is_upper_bound(i))	
							      >				{
							      >					if(-G[i] >= Gmax1)
							      >						Gmax1 = -G[i];
							      >				}
							      >				if(!is_lower_bound(i))	
			{								{
				if(-G[k] >= Gm1) continue;    |					if(G[i] >= Gmax2)
							      >						Gmax2 = G[i];
			}								}
			else	if(-G[k] >= Gm2) continue;    <
		}								}
		else if(is_upper_bound(k))		      |			else	
		{								{
			if(y[k]==+1)			      |				if(!is_upper_bound(i))	
							      >				{
							      >					if(-G[i] >= Gmax2)
							      >						Gmax2 = -G[i];
							      >				}
							      >				if(!is_lower_bound(i))	
			{								{
				if(G[k] >= Gm2) continue;     |					if(G[i] >= Gmax1)
							      >						Gmax1 = G[i];
			}								}
			else	if(G[k] >= Gm1) continue;     <
		}								}
		else continue;				      <
							      <
		--active_size;				      <
		swap_index(k,active_size);		      <
		--k;	// look at the newcomer		      <
	}								}

	// unshrink, check all variables again before final i |		if(unshrink == false && Gmax1 + Gmax2 <= eps*10) 
							      <
	if(unshrinked || -(Gm1 + Gm2) > eps*10) return;	      <
							      <
	unshrinked = true;				      <
	reconstruct_gradient();				      <
							      <
	for(k=l-1;k>=active_size;k--)			      <
	{								{
		if(is_lower_bound(k))			      |			unshrink = true;
		{					      |			reconstruct_gradient();
			if(y[k]==+1)			      |			active_size = l;
			{				      |			info("*");
				if(-G[k] < Gm1) continue;     |		}
			}				      |
			else	if(-G[k] < Gm2) continue;     |		for(i=0;i<active_size;i++)
		}					      |			if (be_shrunk(i, Gmax1, Gmax2))
		else if(is_upper_bound(k))		      <
		{								{
			if(y[k]==+1)			      |				active_size--;
							      >				while (active_size > i)
			{								{
				if(G[k] < Gm2) continue;      |					if (!be_shrunk(active_size, G
							      >					{
							      >						swap_index(i,active_s
							      >						break;
							      >					}
							      >					active_size--;
			}								}
			else	if(G[k] < Gm1) continue;      <
		}								}
		else continue;				      <
							      <
		swap_index(k,active_size);		      <
		active_size++;				      <
		++k;	// look at the newcomer		      <
	}						      <
}								}

double Solver::calculate_rho()					double Solver::calculate_rho()
{								{
	double r;							double r;
	int nr_free = 0;						int nr_free = 0;
	double ub = INF, lb = -INF, sum_free = 0;			double ub = INF, lb = -INF, sum_free = 0;
	for(int i=0;i<active_size;i++)					for(int i=0;i<active_size;i++)
	{								{
		double yG = y[i]*G[i];						double yG = y[i]*G[i];

		if(is_lower_bound(i))			      |			if(is_upper_bound(i))
		{								{
			if(y[i] > 0)			      |				if(y[i]==-1)
				ub = min(ub,yG);						ub = min(ub,yG);
			else								else
				lb = max(lb,yG);						lb = max(lb,yG);
		}								}
		else if(is_upper_bound(i))		      |			else if(is_lower_bound(i))
		{								{
			if(y[i] < 0)			      |				if(y[i]==+1)
				ub = min(ub,yG);						ub = min(ub,yG);
			else								else
				lb = max(lb,yG);						lb = max(lb,yG);
		}								}
		else								else
		{								{
			++nr_free;							++nr_free;
			sum_free += yG;							sum_free += yG;
		}								}
	}								}

	if(nr_free>0)							if(nr_free>0)
		r = sum_free/nr_free;						r = sum_free/nr_free;
	else								else
		r = (ub+lb)/2;							r = (ub+lb)/2;

	return r;							return r;
}								}

//								//
// Solver for nu-svm classification and regression		// Solver for nu-svm classification and regression
//								//
// additional constraint: e^T \alpha = constant			// additional constraint: e^T \alpha = constant
//								//
class Solver_NU : public Solver				      |	class Solver_NU: public Solver
{								{
public:								public:
	Solver_NU() {}							Solver_NU() {}
	void Solve(int l, const Kernel& Q, const double *b, c |		void Solve(int l, const QMatrix& Q, const double *p, 
		   double *alpha, double Cp, double Cn, doubl			   double *alpha, double Cp, double Cn, doubl
		   SolutionInfo* si, int shrinking)				   SolutionInfo* si, int shrinking)
	{								{
		this->si = si;							this->si = si;
		Solver::Solve(l,Q,b,y,alpha,Cp,Cn,eps,si,shri |			Solver::Solve(l,Q,p,y,alpha,Cp,Cn,eps,si,shri
	}								}
private:							private:
	SolutionInfo *si;						SolutionInfo *si;
	int select_working_set(int &i, int &j);				int select_working_set(int &i, int &j);
	double calculate_rho();						double calculate_rho();
							      >		bool be_shrunk(int i, double Gmax1, double Gmax2, dou
	void do_shrinking();						void do_shrinking();
};								};

							      >	// return 1 if already optimal, return 0 otherwise
int Solver_NU::select_working_set(int &out_i, int &out_j)	int Solver_NU::select_working_set(int &out_i, int &out_j)
{								{
	// return i,j which maximize -grad(f)^T d , under con |		// return i,j such that y_i = y_j and
	// if alpha_i == C, d != +1			      |		// i: maximizes -y_i * grad(f)_i, i in I_up(\alpha)
	// if alpha_i == 0, d != -1			      |		// j: minimizes the decrease of obj value
							      |		//    (if quadratic coefficeint <= 0, replace it with
	double Gmax1 = -INF;	// max { -grad(f)_i * d | y_i |		//    -y_j*grad(f)_j < -y_i*grad(f)_i, j in I_low(\al
	int Gmax1_idx = -1;				      |
							      |		double Gmaxp = -INF;
	double Gmax2 = -INF;	// max { -grad(f)_i * d | y_i |		double Gmaxp2 = -INF;
	int Gmax2_idx = -1;				      |		int Gmaxp_idx = -1;
							      |
	double Gmax3 = -INF;	// max { -grad(f)_i * d | y_i |		double Gmaxn = -INF;
	int Gmax3_idx = -1;				      |		double Gmaxn2 = -INF;
							      >		int Gmaxn_idx = -1;
							      >
							      >		int Gmin_idx = -1;
							      >		double obj_diff_min = INF;

	double Gmax4 = -INF;	// max { -grad(f)_i * d | y_i |		for(int t=0;t<active_size;t++)
	int Gmax4_idx = -1;				      |			if(y[t]==+1)
							      <
	for(int i=0;i<active_size;i++)			      <
	{						      <
		if(y[i]==+1)	// y == +1		      <
		{								{
			if(!is_upper_bound(i))	// d = +1     |				if(!is_upper_bound(t))
			{				      |					if(-G[t] >= Gmaxp)
				if(-G[i] > Gmax1)	      <
				{								{
					Gmax1 = -G[i];	      |						Gmaxp = -G[t];
					Gmax1_idx = i;	      |						Gmaxp_idx = t;
				}								}
			}				      |			}
			if(!is_lower_bound(i))	// d = -1     |			else
			{				      |			{
				if(G[i] > Gmax2)	      |				if(!is_lower_bound(t))
							      >					if(G[t] >= Gmaxn)
				{								{
					Gmax2 = G[i];	      |						Gmaxn = G[t];
					Gmax2_idx = i;	      |						Gmaxn_idx = t;
				}								}
			}				      <
		}								}
		else		// y == -1		      |
							      >		int ip = Gmaxp_idx;
							      >		int in = Gmaxn_idx;
							      >		const Qfloat *Q_ip = NULL;
							      >		const Qfloat *Q_in = NULL;
							      >		if(ip != -1) // NULL Q_ip not accessed: Gmaxp=-INF if
							      >			Q_ip = Q->get_Q(ip,active_size);
							      >		if(in != -1)
							      >			Q_in = Q->get_Q(in,active_size);
							      >
							      >		for(int j=0;j<active_size;j++)
							      >		{
							      >			if(y[j]==+1)
		{								{
			if(!is_upper_bound(i))	// d = +1     |				if (!is_lower_bound(j))	
			{								{
				if(-G[i] > Gmax3)	      |					double grad_diff=Gmaxp+G[j];
							      >					if (G[j] >= Gmaxp2)
							      >						Gmaxp2 = G[j];
							      >					if (grad_diff > 0)
				{								{
					Gmax3 = -G[i];	      |						double obj_diff;
					Gmax3_idx = i;	      |						double quad_coef = QD
							      >						if (quad_coef > 0)
							      >							obj_diff = -(
							      >						else
							      >							obj_diff = -(
							      >
							      >						if (obj_diff <= obj_d
							      >						{
							      >							Gmin_idx=j;
							      >							obj_diff_min 
							      >						}
				}								}
			}								}
			if(!is_lower_bound(i))	// d = -1     |			}
							      >			else
							      >			{
							      >				if (!is_upper_bound(j))
			{								{
				if(G[i] > Gmax4)	      |					double grad_diff=Gmaxn-G[j];
				{			      |					if (-G[j] >= Gmaxn2)
					Gmax4 = G[i];	      |						Gmaxn2 = -G[j];
					Gmax4_idx = i;	      |					if (grad_diff > 0)
							      >					{
							      >						double obj_diff;
							      >						double quad_coef = QD
							      >						if (quad_coef > 0)
							      >							obj_diff = -(
							      >						else
							      >							obj_diff = -(
							      >
							      >						if (obj_diff <= obj_d
							      >						{
							      >							Gmin_idx=j;
							      >							obj_diff_min 
							      >						}
				}								}
			}								}
		}								}
	}								}

	if(max(Gmax1+Gmax2,Gmax3+Gmax4) < eps)		      |		if(max(Gmaxp+Gmaxp2,Gmaxn+Gmaxn2) < eps || Gmin_idx =
 		return 1;				      |			return 1;
							      >
							      >		if (y[Gmin_idx] == +1)
							      >			out_i = Gmaxp_idx;
							      >		else
							      >			out_i = Gmaxn_idx;
							      >		out_j = Gmin_idx;
							      >
							      >		return 0;
							      >	}

	if(Gmax1+Gmax2 > Gmax3+Gmax4)			      |	bool Solver_NU::be_shrunk(int i, double Gmax1, double Gmax2, 
							      >	{
							      >		if(is_upper_bound(i))
	{								{
		out_i = Gmax1_idx;			      |			if(y[i]==+1)
		out_j = Gmax2_idx;			      |				return(-G[i] > Gmax1);
							      >			else	
							      >				return(-G[i] > Gmax4);
	}								}
	else						      |		else if(is_lower_bound(i))
	{								{
		out_i = Gmax3_idx;			      |			if(y[i]==+1)
		out_j = Gmax4_idx;			      |				return(G[i] > Gmax2);
							      >			else	
							      >				return(G[i] > Gmax3);
	}								}
	return 0;					      |		else
							      >			return(false);
}								}

void Solver_NU::do_shrinking()					void Solver_NU::do_shrinking()
{								{
	double Gmax1 = -INF;	// max { -grad(f)_i * d | y_i |		double Gmax1 = -INF;	// max { -y_i * grad(f)_i | y
	double Gmax2 = -INF;	// max { -grad(f)_i * d | y_i |		double Gmax2 = -INF;	// max { y_i * grad(f)_i | y_
	double Gmax3 = -INF;	// max { -grad(f)_i * d | y_i |		double Gmax3 = -INF;	// max { -y_i * grad(f)_i | y
	double Gmax4 = -INF;	// max { -grad(f)_i * d | y_i |		double Gmax4 = -INF;	// max { y_i * grad(f)_i | y_

	int k;						      |		// find maximal violating pair first
	for(k=0;k<active_size;k++)			      |		int i;
							      >		for(i=0;i<active_size;i++)
	{								{
		if(!is_upper_bound(k))			      |			if(!is_upper_bound(i))
		{								{
			if(y[k]==+1)			      |				if(y[i]==+1)
			{								{
				if(-G[k] > Gmax1) Gmax1 = -G[ |					if(-G[i] > Gmax1) Gmax1 = -G[
			}								}
			else	if(-G[k] > Gmax3) Gmax3 = -G[ |				else	if(-G[i] > Gmax4) Gmax4 = -G[
		}								}
		if(!is_lower_bound(k))			      |			if(!is_lower_bound(i))
		{								{
			if(y[k]==+1)			      |				if(y[i]==+1)
			{								{	
				if(G[k] > Gmax2) Gmax2 = G[k] |					if(G[i] > Gmax2) Gmax2 = G[i]
			}								}
			else	if(G[k] > Gmax4) Gmax4 = G[k] |				else	if(G[i] > Gmax3) Gmax3 = G[i]
		}								}
	}								}

	double Gm1 = -Gmax2;				      |		if(unshrink == false && max(Gmax1+Gmax2,Gmax3+Gmax4) 
	double Gm2 = -Gmax1;				      <
	double Gm3 = -Gmax4;				      <
	double Gm4 = -Gmax3;				      <
							      <
	for(k=0;k<active_size;k++)			      <
	{								{
		if(is_lower_bound(k))			      |			unshrink = true;
		{					      |			reconstruct_gradient();
			if(y[k]==+1)			      |			active_size = l;
			{				      <
				if(-G[k] >= Gm1) continue;    <
			}				      <
			else	if(-G[k] >= Gm3) continue;    <
		}					      <
		else if(is_upper_bound(k))		      <
		{					      <
			if(y[k]==+1)			      <
			{				      <
				if(G[k] >= Gm2) continue;     <
			}				      <
			else	if(G[k] >= Gm4) continue;     <
		}					      <
		else continue;				      <
							      <
		--active_size;				      <
		swap_index(k,active_size);		      <
		--k;	// look at the newcomer		      <
	}								}

	// unshrink, check all variables again before final i |		for(i=0;i<active_size;i++)
							      |			if (be_shrunk(i, Gmax1, Gmax2, Gmax3, Gmax4))
	if(unshrinked || max(-(Gm1+Gm2),-(Gm3+Gm4)) > eps*10) <
							      <
	unshrinked = true;				      <
	reconstruct_gradient();				      <
							      <
	for(k=l-1;k>=active_size;k--)			      <
	{						      <
		if(is_lower_bound(k))			      <
		{					      <
			if(y[k]==+1)			      <
			{				      <
				if(-G[k] < Gm1) continue;     <
			}				      <
			else	if(-G[k] < Gm3) continue;     <
		}					      <
		else if(is_upper_bound(k))		      <
		{								{
			if(y[k]==+1)			      |				active_size--;
							      >				while (active_size > i)
			{								{
				if(G[k] < Gm2) continue;      |					if (!be_shrunk(active_size, G
							      >					{
							      >						swap_index(i,active_s
							      >						break;
							      >					}
							      >					active_size--;
			}								}
			else	if(G[k] < Gm4) continue;      <
		}								}
		else continue;				      <
							      <
		swap_index(k,active_size);		      <
		active_size++;				      <
		++k;	// look at the newcomer		      <
	}						      <
}								}

double Solver_NU::calculate_rho()				double Solver_NU::calculate_rho()
{								{
	int nr_free1 = 0,nr_free2 = 0;					int nr_free1 = 0,nr_free2 = 0;
	double ub1 = INF, ub2 = INF;					double ub1 = INF, ub2 = INF;
	double lb1 = -INF, lb2 = -INF;					double lb1 = -INF, lb2 = -INF;
	double sum_free1 = 0, sum_free2 = 0;				double sum_free1 = 0, sum_free2 = 0;

	for(int i=0;i<active_size;i++)					for(int i=0;i<active_size;i++)
	{								{
		if(y[i]==+1)							if(y[i]==+1)
		{								{
			if(is_lower_bound(i))		      |				if(is_upper_bound(i))
				ub1 = min(ub1,G[i]);	      <
			else if(is_upper_bound(i))	      <
				lb1 = max(lb1,G[i]);						lb1 = max(lb1,G[i]);
							      >				else if(is_lower_bound(i))
							      >					ub1 = min(ub1,G[i]);
			else								else
			{								{
				++nr_free1;							++nr_free1;
				sum_free1 += G[i];						sum_free1 += G[i];
			}								}
		}								}
		else								else
		{								{
			if(is_lower_bound(i))		      |				if(is_upper_bound(i))
				ub2 = min(ub2,G[i]);	      <
			else if(is_upper_bound(i))	      <
				lb2 = max(lb2,G[i]);						lb2 = max(lb2,G[i]);
							      >				else if(is_lower_bound(i))
							      >					ub2 = min(ub2,G[i]);
			else								else
			{								{
				++nr_free2;							++nr_free2;
				sum_free2 += G[i];						sum_free2 += G[i];
			}								}
		}								}
	}								}

	double r1,r2;							double r1,r2;
	if(nr_free1 > 0)						if(nr_free1 > 0)
		r1 = sum_free1/nr_free1;					r1 = sum_free1/nr_free1;
	else								else
		r1 = (ub1+lb1)/2;						r1 = (ub1+lb1)/2;
									
	if(nr_free2 > 0)						if(nr_free2 > 0)
		r2 = sum_free2/nr_free2;					r2 = sum_free2/nr_free2;
	else								else
		r2 = (ub2+lb2)/2;						r2 = (ub2+lb2)/2;
									
	si->r = (r1+r2)/2;						si->r = (r1+r2)/2;
	return (r1-r2)/2;						return (r1-r2)/2;
}								}

//								//
// Q matrices for various formulations				// Q matrices for various formulations
//								//
class SVC_Q: public Kernel					class SVC_Q: public Kernel
{ 								{ 
public:								public:
	SVC_Q(const svm_problem& prob, const svm_parameter& p		SVC_Q(const svm_problem& prob, const svm_parameter& p
	:Kernel(prob.l, prob.x, param)					:Kernel(prob.l, prob.x, param)
	{								{
		clone(y,y_,prob.l);						clone(y,y_,prob.l);
		cache = new Cache(prob.l,(int)(param.cache_si |			cache = new Cache(prob.l,(long int)(param.cac
							      >			QD = new double[prob.l];
							      >			for(int i=0;i<prob.l;i++)
							      >				QD[i] = (this->*kernel_function)(i,i)
	}								}
									
	Qfloat *get_Q(int i, int len) const				Qfloat *get_Q(int i, int len) const
	{								{
		Qfloat *data;							Qfloat *data;
		int start;				      |			int start, j;
		if((start = cache->get_data(i,&data,len)) < l			if((start = cache->get_data(i,&data,len)) < l
		{								{
			for(int j=start;j<len;j++)	      |				for(j=start;j<len;j++)
				data[j] = (Qfloat)(y[i]*y[j]*					data[j] = (Qfloat)(y[i]*y[j]*
		}								}
		return data;							return data;
	}								}

							      >		double *get_QD() const
							      >		{
							      >			return QD;
							      >		}
							      >
	void swap_index(int i, int j) const				void swap_index(int i, int j) const
	{								{
		cache->swap_index(i,j);						cache->swap_index(i,j);
		Kernel::swap_index(i,j);					Kernel::swap_index(i,j);
		swap(y[i],y[j]);						swap(y[i],y[j]);
							      >			swap(QD[i],QD[j]);
	}								}

	~SVC_Q()							~SVC_Q()
	{								{
		delete[] y;							delete[] y;
		delete cache;							delete cache;
							      >			delete[] QD;
	}								}
private:							private:
	schar *y;							schar *y;
	Cache *cache;							Cache *cache;
							      >		double *QD;
};								};

class ONE_CLASS_Q: public Kernel				class ONE_CLASS_Q: public Kernel
{								{
public:								public:
	ONE_CLASS_Q(const svm_problem& prob, const svm_parame		ONE_CLASS_Q(const svm_problem& prob, const svm_parame
	:Kernel(prob.l, prob.x, param)					:Kernel(prob.l, prob.x, param)
	{								{
		cache = new Cache(prob.l,(int)(param.cache_si |			cache = new Cache(prob.l,(long int)(param.cac
							      >			QD = new double[prob.l];
							      >			for(int i=0;i<prob.l;i++)
							      >				QD[i] = (this->*kernel_function)(i,i)
	}								}
									
	Qfloat *get_Q(int i, int len) const				Qfloat *get_Q(int i, int len) const
	{								{
		Qfloat *data;							Qfloat *data;
		int start;				      |			int start, j;
		if((start = cache->get_data(i,&data,len)) < l			if((start = cache->get_data(i,&data,len)) < l
		{								{
			for(int j=start;j<len;j++)	      |				for(j=start;j<len;j++)
				data[j] = (Qfloat)(this->*ker					data[j] = (Qfloat)(this->*ker
		}								}
		return data;							return data;
	}								}

							      >		double *get_QD() const
							      >		{
							      >			return QD;
							      >		}
							      >
	void swap_index(int i, int j) const				void swap_index(int i, int j) const
	{								{
		cache->swap_index(i,j);						cache->swap_index(i,j);
		Kernel::swap_index(i,j);					Kernel::swap_index(i,j);
							      >			swap(QD[i],QD[j]);
	}								}

	~ONE_CLASS_Q()							~ONE_CLASS_Q()
	{								{
		delete cache;							delete cache;
							      >			delete[] QD;
	}								}
private:							private:
	Cache *cache;							Cache *cache;
							      >		double *QD;
};								};

class SVR_Q: public Kernel					class SVR_Q: public Kernel
{ 								{ 
public:								public:
	SVR_Q(const svm_problem& prob, const svm_parameter& p		SVR_Q(const svm_problem& prob, const svm_parameter& p
	:Kernel(prob.l, prob.x, param)					:Kernel(prob.l, prob.x, param)
	{								{
		l = prob.l;							l = prob.l;
		cache = new Cache(l,(int)(param.cache_size*(1 |			cache = new Cache(l,(long int)(param.cache_si
							      >			QD = new double[2*l];
		sign = new schar[2*l];						sign = new schar[2*l];
		index = new int[2*l];						index = new int[2*l];
		for(int k=0;k<l;k++)						for(int k=0;k<l;k++)
		{								{
			sign[k] = 1;							sign[k] = 1;
			sign[k+l] = -1;							sign[k+l] = -1;
			index[k] = k;							index[k] = k;
			index[k+l] = k;							index[k+l] = k;
							      >				QD[k] = (this->*kernel_function)(k,k)
							      >				QD[k+l] = QD[k];
		}								}
		buffer[0] = new Qfloat[2*l];					buffer[0] = new Qfloat[2*l];
		buffer[1] = new Qfloat[2*l];					buffer[1] = new Qfloat[2*l];
		next_buffer = 0;						next_buffer = 0;
	}								}

	void swap_index(int i, int j) const				void swap_index(int i, int j) const
	{								{
		swap(sign[i],sign[j]);						swap(sign[i],sign[j]);
		swap(index[i],index[j]);					swap(index[i],index[j]);
							      >			swap(QD[i],QD[j]);
	}								}
									
	Qfloat *get_Q(int i, int len) const				Qfloat *get_Q(int i, int len) const
	{								{
		Qfloat *data;							Qfloat *data;
		int real_i = index[i];			      |			int j, real_i = index[i];
		if(cache->get_data(real_i,&data,l) < l)				if(cache->get_data(real_i,&data,l) < l)
		{								{
			for(int j=0;j<l;j++)		      |				for(j=0;j<l;j++)
				data[j] = (Qfloat)(this->*ker					data[j] = (Qfloat)(this->*ker
		}								}

		// reorder and copy						// reorder and copy
		Qfloat *buf = buffer[next_buffer];				Qfloat *buf = buffer[next_buffer];
		next_buffer = 1 - next_buffer;					next_buffer = 1 - next_buffer;
		schar si = sign[i];						schar si = sign[i];
		for(int j=0;j<len;j++)			      |			for(j=0;j<len;j++)
			buf[j] = si * sign[j] * data[index[j] |				buf[j] = (Qfloat) si * (Qfloat) sign[
		return buf;							return buf;
	}								}

							      >		double *get_QD() const
							      >		{
							      >			return QD;
							      >		}
							      >
	~SVR_Q()							~SVR_Q()
	{								{
		delete cache;							delete cache;
		delete[] sign;							delete[] sign;
		delete[] index;							delete[] index;
		delete[] buffer[0];						delete[] buffer[0];
		delete[] buffer[1];						delete[] buffer[1];
							      >			delete[] QD;
	}								}
private:							private:
	int l;								int l;
	Cache *cache;							Cache *cache;
	schar *sign;							schar *sign;
	int *index;							int *index;
	mutable int next_buffer;					mutable int next_buffer;
	Qfloat* buffer[2];				      |		Qfloat *buffer[2];
							      >		double *QD;
};								};

//								//
// construct and solve various formulations			// construct and solve various formulations
//								//
							      |	static void solve_c_svc(
static void solve_rsvmssvm(				      <
	const svm_problem *prob, const svm_parameter* param,		const svm_problem *prob, const svm_parameter* param,
	double *alpha, Solver::SolutionInfo* si, double Cp, d |		double *alpha, Solver::SolutionInfo* si, double Cp, d
{								{
	int l = prob->l;						int l = prob->l;
							      >		double *minus_ones = new double[l];
	schar *y = new schar[l];					schar *y = new schar[l];

	int lb = (int) (param->nu*l);			      |		int i;
 	if(l >= BIG_PROB_THRESHOLD && lb >= REDUCE_THRESHOLD) <
		lb = param->shrinking;			      <
		printf("nu changes to %d/(subprob size=%d)\n" <
	}						      <
							      <
	int *workpt = new int[l];			      <
	int lbp1 = lb+1;				      <
//	double *alphab = new double[lbp1];		      <
	double *Qb = new double[l*lbp1];		      <
	double *H = new double[lbp1*lbp1];		      <
	int i,j;					      <

	for(i=0;i<l;i++)						for(i=0;i<l;i++)
	{								{
		alpha[i] = 0;							alpha[i] = 0;
		if(prob->y[i] > 0) {			      |			minus_ones[i] = -1;
		  y[i] = +1; 				      |			if(prob->y[i] > 0) y[i] = +1; else y[i] = -1;
		} else {				      <
		  y[i]=-1; 				      <
		}					      <
	}								}

	int np=0, nn=0;					      |		Solver s;
							      |		s.Solve(l, SVC_Q(*prob,*param,y), minus_ones, y,
	for(i=0;i<l;i++) 				      |			alpha, Cp, Cn, param->eps, si, param->shrinki
	  workpt[i] = i;				      <
							      <
	for(i=0;i<lb;i++) {				      <
	  int k = rand()%(l-i)+i;			      <
	  int tmp = workpt[i];				      <
	  workpt[i] = workpt[k];			      <
	  workpt[k] = tmp;				      <
	}						      <
							      <
#if 0							      <
	double *qtemp = new double[l];			      <
	double *heap = new double[lb];			      <
	double temp, mintemp;				      <
	int minindex;					      <
							      <
							      <
	int start;					      <
							      <
	{						      <
	  struct tms buffer;				      <
	  times(&buffer);				      <
	  start = buffer.tms_utime;			      <
	}						      <
							      <
	for(j=0;j<lb;j++)				      <
	  {						      <
	    heap[j]=0;					      <
	    minindex = 1;				      <
	  for(i=0;i<l;i++)				      <
	    {						      <
		  Qb[j*l+i] = Kernel::k_function(prob->x[i],p <
		  //		  if(y[j]!=y[i])	      <
		{					      <
		  heap[j]+=fabs(Qb[j*l+i]);		      <
		  minindex++;				      <
		}					      <
	    }						      <
	  heap[j]/= minindex;				      <
	  }						      <
							      <
	for(j=lb;j<l;j++)				      <
	  {						      <
	    temp = 0;					      <
	    minindex = 1;				      <
	    for(i=0;i<l;i++)				      <
	      {						      <
		    qtemp[i] = Kernel::k_function(prob->x[i], <
		    //		    if(y[j] != y[i])	      <
		  {					      <
		    temp+=fabs(qtemp[i]);		      <
		    minindex++;				      <
		  }					      <
	      }						      <
	    temp/=minindex;				      <
							      <
	    for(minindex =0, i=1, mintemp=heap[0];i<lb;i++)   <
	      if(heap[i]<mintemp)			      <
		{					      <
		mintemp = heap[i];			      <
		minindex = i;				      <
		}					      <
							      <
	    if(temp>mintemp)				      <
	      {						      <
		workpt[minindex] = j;			      <
		heap[minindex] = temp;			      <
		memcpy(&(Qb[minindex*l]), qtemp,sizeof(double <
	      }						      <
	  }						      <
							      <
	{						      <
	  struct tms buffer;				      <
	  times(&buffer);				      <
	  mytime += buffer.tms_utime-start;		      <
	}						      <
#endif							      <

	for(i=0;i<lb;i++) {				      |		double sum_alpha=0;
		if (y[workpt[i]]==1) np++;		      |		for(i=0;i<l;i++)
		else nn++;				      |			sum_alpha += alpha[i];
	}						      <
	printf("%d %d\n", np, nn);			      <
							      <
#if 0							      <
	for(i=0;i<l;i++) 				      <
	{						      <
	   for (j=0;j<lb;j++)				      <
	      Qb[i*lbp1+j] = Kernel::k_function(prob->x[i],pr <
	   Qb[i*lbp1+lb] = (double) y[i];		      <
	}						      <
#endif							      <

        for (j=0;j<lb;j++)				      |		if (Cp==Cn)
        {						      |			info("nu = %f\n", sum_alpha/(Cp*prob->l));
            for(i=0;i<l;i++)				      <
              Qb[j*l+i] = Kernel::k_function(prob->x[i],prob- <
        }						      <
							      <
        for(i=0;i<l;i++)				      <
          Qb[lb*l+i] = (double) y[i];			      <
							      <
	//call solvebqp					      <
	BQP qp;						      <
	qp.l = l;					      <
	qp.n = lbp1;					      <
	qp.eps = param->eps;				      <
	qp.p = new double[1];				      <
							      <
	qp.C = new double[1];				      <
	qp.C[0] = Cp;					      <
	qp.x = new double[lbp1];			      <
	for(i=0;i<lbp1;i++)				      <
		qp.x[i] = 0; 				      <
	qp.Q = Qb;					      <
							      <
		solvebqp(&qp, param->p);		      <
							      <
	//after calling solvebqp			      <
							      <
	for(i=0;i<lb;i++) 				      <
		alpha[workpt[i]] = qp.x[i]*y[workpt[i]];      <
	si->rho = -qp.x[lb];				      <
	si->upper_bound_p = Cp;				      <
	si->upper_bound_n = Cp;				      <
	si->obj = 0; //unassigned			      <

	delete qp.p;					      |		for(i=0;i<l;i++)
	delete qp.C;					      |			alpha[i] *= y[i];

							      >		delete[] minus_ones;
	delete[] y;							delete[] y;
	delete[] Qb;					      <
	delete[] workpt;				      <
	delete[] H;					      <
//	delete[] alphab;				      <
							      <
}								}

static void solve_rsvmeq(				      |	static void solve_nu_svc(
	const svm_problem *prob, const svm_parameter* param,  |		const svm_problem *prob, const svm_parameter *param,
	double *alpha, Solver::SolutionInfo* si, double Cp, d |		double *alpha, Solver::SolutionInfo* si)
{								{
							      >		int i;
	int l = prob->l;						int l = prob->l;
							      >		double nu = param->nu;
							      >
	schar *y = new schar[l];					schar *y = new schar[l];

	int lb = (int) (param->nu*l);			      |		for(i=0;i<l;i++)
 	if(l >= BIG_PROB_THRESHOLD && lb >= REDUCE_THRESHOLD) |			if(prob->y[i]>0)
		lb = param->shrinking;			      |				y[i] = +1;
		printf("nu changes to %d/(subprob size=%d)\n" |			else
	}						      |				y[i] = -1;
							      <
	int *workpt = new int[l];			      <
	int lbp1 = lb+1;				      <
	double *alphab = new double[lbp1];		      <
	double *Qbt = new double[lbp1*l];		      <
	double *H = new double[lbp1*lbp1];		      <
	int i,j,indef, inc=1;				      <

	double *work = new double[lbp1*lbp1];		      |		double sum_pos = nu*l/2;
	int *ipiv = new int[lbp1];			      |		double sum_neg = nu*l/2;
							      <
	int lp=0, ln=0;					      <
	for(i=0;i<l;i++)				      <
	{						      <
		alpha[i] = 0;				      <
		if(prob->y[i] > 0) {			      <
		  y[i] = +1; 				      <
		  lp++;					      <
		} else {				      <
		  y[i]=-1;				      <
		  ln++; 				      <
		}					      <
	}						      <
	Cn = (double)(lp+1)/(ln+1);			      <
	printf("lp= %d, ln=%d, Cn = %f\n", lp, ln, Cn);	      <
							      <
	int np=0, nn=0;					      <
	for(i=0;i<l;i++) 				      <
	  workpt[i] = i;				      <
							      <
							      <
	for(i=0;i<lb;i++) {				      <
	  int k = rand()%(l-i)+i;			      <
	  int tmp = workpt[i];				      <
	  workpt[i] = workpt[k];			      <
	  workpt[k] = tmp;				      <
	}						      <
							      <
	double *qtemp = new double[l];			      <
	double *heap = new double[lb];			      <
	double temp, mintemp;				      <
	int minindex;					      <
							      <
							      <
	int start;					      <
							      <
	{						      <
	  struct tms buffer;				      <
	  times(&buffer);				      <
	  start = buffer.tms_utime;			      <
	}						      <
							      <
#if 0							      <
	for(j=0;j<lb;j++)				      <
	  {						      <
	    heap[j]=0;					      <
	    minindex = 1;				      <
	  for(i=0;i<l;i++)				      <
	    {						      <
		  Qbt[j*l+i] = Kernel::k_function(prob->x[i], <
		  //		  if(y[j]!=y[i])	      <
		{					      <
		  heap[j]+=fabs(Qbt[j*l+i]);		      <
		  minindex++;				      <
		}					      <
	    }						      <
	  heap[j]/= minindex;				      <
	  }						      <
							      <
	for(j=lb;j<l;j++)				      <
	  {						      <
	    temp = 0;					      <
	    minindex = 1;				      <
	    for(i=0;i<l;i++)				      <
	      {						      <
		    qtemp[i] = Kernel::k_function(prob->x[i], <
		    //		    if(y[j] != y[i])	      <
		  {					      <
		    temp+=fabs(qtemp[i]);		      <
		    minindex++;				      <
		  }					      <
	      }						      <
	    temp/=minindex;				      <
							      <
	    for(minindex =0, i=1, mintemp=heap[0];i<lb;i++)   <
	      if(heap[i]<mintemp)			      <
		{					      <
		mintemp = heap[i];			      <
		minindex = i;				      <
		}					      <
							      <
	    if(temp>mintemp)				      <
	      {						      <
		workpt[minindex] = j;			      <
		heap[minindex] = temp;			      <
		memcpy(&(Qbt[minindex*l]), qtemp,sizeof(doubl <
	      }						      <
	  }						      <
#endif							      <
	{						      <
	  struct tms buffer;				      <
	  times(&buffer);				      <
	  mytime += buffer.tms_utime-start;		      <
	}						      <
							      <
							      <
	for(i=0;i<lb;i++) {				      <
		if (y[workpt[i]]==1) np++;		      <
		else nn++;				      <
	}						      <
	printf("%d %d\n", np, nn);			      <
							      <
	for (j=0;j<lb;j++)				      <
	{						      <
	    for(i=0;i<l;i++) 				      <
	      {						      <
	      	      Qbt[j*l+i] = Kernel::k_function(prob->x <
	      }						      <
	}						      <
	for(i=0;i<l;i++)				      <
	  Qbt[lb*l+i] = (double) y[i];			      <
							      <
	for(i=0;i<lbp1;i++)				      <
        {						      <
	  for(j=0;j<lbp1;j++) {				      <
	    H[i*lbp1+j]=0;				      <
	    for(int k=0;k<l;k++)			      <
	      {						      <
	      /*		if(modified == 2 && y[k]==-1) <
		      H[i*lbp1+j]+=Qbt[i*l+k]*Qbt[j*l+k]*Cn;  <
		else					      <
	      */					      <
		      H[i*lbp1+j]+=Qbt[i*l+k]*Qbt[j*l+k];     <
	      }						      <
	  }						      <
							      <
	  alphab[i]=0;					      <
	  for(int k=0;k<l;k++)				      <
	    {						      <
	      /*					      <
		if(modified == 2 && y[k]==-1)		      <
		    alphab[i]+=Qbt[i*l+k]*Cn;		      <
		else					      <
	      */					      <
		    alphab[i]+=Qbt[i*l+k];		      <
	    }						      <
	}						      <
							      <
	if (modified==1) {				      <
		for (i=0;i<lb;i++)			      <
			for (j=0;j<lb;j++)		      <
				H[i*lbp1+j]+=Qbt[i*l+workpt[j <
		H[lb*lbp1+lb]+=1;			      <
		i = lbp1*lbp1;				      <
		j = 1;					      <
							      <
		dsysv_("L", &lbp1, &j, H, &lbp1,ipiv,alphab,& <
		if(indef != 0)				      <
		   printf("error! %d\n", indef); 	      <
	}						      <
	else						      <
	{						      <
		for (i=0;i<lbp1;i++)			      <
			H[i*lbp1+i]+=0.5/Cp;		      <
							      <
		dpotf2_("L", &lbp1, H, &lbp1, &indef);	      <
//		for (i=0;i<lb;i++){			      <
//			for (j=0;j<lb;j++) {		      <
//				printf("%.2f", H[i*lbp1+j]);  <
//			}				      <
//			printf(",\n");			      <
//		}					      <
							      <
		dtrsv_("L", "N", "N", &lbp1, H, &lbp1, alphab <
		dtrsv_("L", "T", "N", &lbp1, H, &lbp1, alphab <
	}						      <
	for(i=0;i<lb;i++) 				      <
		alpha[workpt[i]] = alphab[i]*y[workpt[i]];    <
	si->rho = -alphab[lb];				      <
	si->upper_bound_p = Cp;				      <
	si->upper_bound_n = Cp;				      <
	si->obj = 0;					      <
							      <
	delete[] y;					      <
	delete[] Qbt;					      <
	delete[] workpt;				      <
	delete[] H;					      <
	delete[] alphab;				      <
}							      <
							      <
static void solve_rsvmlsvm(				      <
	const svm_problem *prob, const svm_parameter* param,  <
	double *alpha, Solver::SolutionInfo* si, double Cp, d <
{							      <
	int l = prob->l;				      <
	schar *y = new schar[l];			      <
							      <
	int lb = (int) (param->nu*l);			      <
 	if(l >= BIG_PROB_THRESHOLD && lb >= REDUCE_THRESHOLD) <
		lb = param->shrinking;			      <
		printf("nu changes to %d/(subprob size=%d)\n" <
	}						      <
							      <
	int *workpt = new int[l];			      <
	int lbp1 = lb+1;				      <
	double *alphab = new double[max(l,lbp1)];	      <
	double *alphatmp= new double[max(l,lbp1)];	      <
	double *alphatmp1= new double[max(l,lbp1)];	      <
	double *Qbt = new double[lbp1*l];		      <
	double *H = new double[lbp1*lbp1];		      <
	double zero=0, one=1, mone=-1, twocp=2*Cp;	      <
	int i,j,k,indef, inc=1; 			      <
							      <
	for(i=0;i<l;i++)				      <
	{						      <
		alpha[i] = 0;				      <
		alphab[i]=0;				      <
		if(prob->y[i] > 0) {			      <
			y[i] = +1; 			      <
		} else {				      <
			y[i]=-1; 			      <
		}					      <
	}						      <
							      <
	for(i=0;i<l;i++) workpt[i] = i;			      <
							      <
	for(i=0;i<lb;i++) {				      <
		k = rand()%(l-i)+i;			      <
		int tmp = workpt[i];			      <
		workpt[i] = workpt[k];			      <
		workpt[k] = tmp;			      <
	}						      <
	      						      <
	for (j=0;j<lb;j++)				      <
	{						      <
		for(i=0;i<l;i++) {			      <
			Qbt[j*l+i] = Kernel::k_function(prob- <
			//			printf("%20.1 <
		}					      <
		//		printf("\n");		      <
	}						      <
	for(i=0;i<l;i++)				      <
		Qbt[lb*l+i] = (double) y[i];		      <
							      <
	/* finding Qbt*Qbt' + I/(2C) */			      <
	for(i=0;i<lbp1;i++)				      <
        {						      <
		for(j=i;j<lbp1;j++) {			      <
			H[i*lbp1+j]=0;			      <
			for(int k=0;k<l;k++)		      <
				H[i*lbp1+j]+=Qbt[i*l+k]*Qbt[j <
			H[j*lbp1+i]=H[i*lbp1+j];	      <
		}					      <
		H[i*lbp1+i]+=1/(2*Cp);			      <
	}						      <
	dpotf2_("L", &lbp1, H, &lbp1, &indef);		      <
							      <
	int iter=0;					      <
	int counter = min(l,100)+1;			      <
							      <
	while(1)					      <
        {						      <
							      <
		if (iter >= 500) break; 		      <
							      <
		if(--counter == 0)			      <
		{					      <
			counter = min(l,100);		      <
			info("."); info_flush();	      <
		}					      <
							      <
		/*  \alphatmp = \bQ' \balpha */		      <
		dgemv_("T", &l, &lbp1, &one, Qbt, &l, alphab, <
							      <
							      <
		/* \alphatmp = \bQ \alphatmp + (1/2C - \beta) <
		/* assume \beta = 0.95/C */		      <
		double beta = 0.95;			      <
		for (i=0;i<l;i++) 			      <
			alphatmp1[i] = (0.5-beta)/Cp*alphab[i <
		dgemv_("N", &l, &lbp1, &one, Qbt, &l, alphatm <
							      <
		/* stopping condition */		      <
		iter++;					      <
		double dmax=0, dmin=0;			      <
		double alphamin = alphab[0];		      <
		for (i=0;i<l;i++) {			      <
			alphatmp[i] = alphatmp1[i] + beta*alp <
			if (dmin > alphatmp[i]) 	      <
				dmin = alphatmp[i];	      <
			//			if (alphab[i] <
			if (alphab[i] > param->eps && dmax <  <
				dmax = alphatmp[i];	      <
			alphamin=min(alphamin, alphab[i]);    <
		}					      <
		//if (dmin-dmax >= -param->eps && alphamin >= <
		if (dmin-dmax >= -param->eps && alphamin >= - <
//		if (dmin-dmax >= -param->eps*lbp1 && alphamin <
			printf("%g %g %g\n", dmin, dmax, alph <
			printf("iter = %d\n ", iter);	      <
			break;				      <
		}					      <
		/* \alphab = (\alphab)_+ + e */		      <
		for (i=0;i<l;i++) {			      <
			alphab[i] = max(alphatmp1[i],zero) +1 <
			alphatmp[i] = alphab[i];	      <
		}					      <
							      <
		/* \alphatmp1 = \bQ' * \alphatmp  */	      <
		dgemv_("T", &l, &lbp1, &one, Qbt, &l, alphatm <
		dtrsv_("L", "N", "N", &lbp1, H, &lbp1, alphat <
		dtrsv_("L", "T", "N", &lbp1, H, &lbp1, alphat <
		dgemv_("N", &l, &lbp1, &one, Qbt, &l, alphatm <
							      <
		/* alphab <- (I - ...)*alphab = alphab - alph <
		daxpy_(&l, &mone, alphatmp, &inc, alphab, &in <
	  						      <
		dscal_(&l, &twocp, alphab, &inc);	      <
	}						      <
							      <
							      <
	/*  final alpha = \bQ' \balpha */		      <
	dgemv_("T", &l, &lbp1, &one, Qbt, &l, alphab, &inc, & <
							      <
	for(i=0;i<lb;i++) 				      <
		{					      <
		alpha[workpt[i]] = alphatmp[i]*y[workpt[i]];  <
		}					      <
	si->rho = -alphatmp[lb];			      <
	si->upper_bound_p = Cp;				      <
	si->upper_bound_n = Cp;				      <
	si->obj = 0;					      <
							      <
	delete[] y;					      <
	delete[] Qbt;					      <
	delete[] workpt;				      <
	delete[] H;					      <
	delete[] alphab;				      <
}							      <
							      <
							      <
static void solve_c_svc(				      <
	const svm_problem *prob, const svm_parameter* param,  <
	double *alpha, Solver::SolutionInfo* si, double Cp, d <
{							      <
	int l = prob->l;				      <
	double *minus_ones = new double[l];		      <
	schar *y = new schar[l];			      <
							      <
	int i;						      <
							      <
	for(i=0;i<l;i++)				      <
	{						      <
		alpha[i] = 0;				      <
		minus_ones[i] = -1;			      <
		if(prob->y[i] > 0) y[i] = +1; else y[i]=-1;   <
	}						      <
							      <
	Solver s;					      <
	s.Solve(l, SVC_Q(*prob,*param,y), minus_ones, y,      <
		alpha, Cp, Cn, param->eps, si, param->shrinki <
							      <
	double sum_alpha=0;				      <
	for(i=0;i<l;i++)				      <
		sum_alpha += alpha[i];			      <
							      <
	info("nu = %f\n", sum_alpha/(param->C*prob->l));      <
							      <
	for(i=0;i<l;i++)				      <
		alpha[i] *= y[i];			      <
							      <
	delete[] minus_ones;				      <
	delete[] y;					      <
}							      <
							      <
static void solve_nu_svc(				      <
	const svm_problem *prob, const svm_parameter *param,  <
	double *alpha, Solver::SolutionInfo* si)	      <
{							      <
	int i;						      <
	int l = prob->l;				      <
	double nu = param->nu;				      <
							      <
	int y_pos = 0;					      <
	int y_neg = 0;					      <
	schar *y = new schar[l];			      <
							      <
	for(i=0;i<l;i++)				      <
		if(prob->y[i]>0)			      <
		{					      <
			y[i] = +1;			      <
			++y_pos;			      <
		}					      <
		else					      <
		{					      <
			y[i] = -1;			      <
			++y_neg;			      <
		}					      <
							      <
	if(nu < 0 || nu*l/2 > min(y_pos,y_neg))		      <
	{						      <
		fprintf(stderr,"specified nu is infeasible\n" <
		exit(1);				      <
	}						      <
							      <
	double sum_pos = nu*l/2;			      <
	double sum_neg = nu*l/2;			      <

	for(i=0;i<l;i++)						for(i=0;i<l;i++)
		if(y[i] == +1)							if(y[i] == +1)
		{								{
			alpha[i] = min(1.0,sum_pos);					alpha[i] = min(1.0,sum_pos);
			sum_pos -= alpha[i];						sum_pos -= alpha[i];
		}								}
		else								else
		{								{
			alpha[i] = min(1.0,sum_neg);					alpha[i] = min(1.0,sum_neg);
			sum_neg -= alpha[i];						sum_neg -= alpha[i];
		}								}

	double *zeros = new double[l];					double *zeros = new double[l];

	for(i=0;i<l;i++)						for(i=0;i<l;i++)
		zeros[i] = 0;							zeros[i] = 0;

	Solver_NU s;							Solver_NU s;
	s.Solve(l, SVC_Q(*prob,*param,y), zeros, y,			s.Solve(l, SVC_Q(*prob,*param,y), zeros, y,
		alpha, 1.0, 1.0, param->eps, si,  param->shri			alpha, 1.0, 1.0, param->eps, si,  param->shri
	double r = si->r;						double r = si->r;

	info("C = %f\n",1/r);						info("C = %f\n",1/r);

	for(i=0;i<l;i++)						for(i=0;i<l;i++)
		alpha[i] *= y[i]/r;						alpha[i] *= y[i]/r;

	si->rho /= r;							si->rho /= r;
	si->obj /= (r*r);						si->obj /= (r*r);
	si->upper_bound_p = 1/r;					si->upper_bound_p = 1/r;
	si->upper_bound_n = 1/r;					si->upper_bound_n = 1/r;

	delete[] y;							delete[] y;
	delete[] zeros;							delete[] zeros;
}								}

static void solve_one_class(					static void solve_one_class(
	const svm_problem *prob, const svm_parameter *param,		const svm_problem *prob, const svm_parameter *param,
	double *alpha, Solver::SolutionInfo* si)			double *alpha, Solver::SolutionInfo* si)
{								{
	int l = prob->l;						int l = prob->l;
	double *zeros = new double[l];					double *zeros = new double[l];
	schar *ones = new schar[l];					schar *ones = new schar[l];
	int i;								int i;

	int n = (int)(param->nu*prob->l);	// # of alpha		int n = (int)(param->nu*prob->l);	// # of alpha
	if(n>=prob->l)					      |
	{						      <
		fprintf(stderr,"nu must be in (0,1)\n");      <
		exit(1);				      <
	}						      <
	for(i=0;i<n;i++)						for(i=0;i<n;i++)
		alpha[i] = 1;							alpha[i] = 1;
	alpha[n] = param->nu * prob->l - n;		      |		if(n<prob->l)
							      >			alpha[n] = param->nu * prob->l - n;
	for(i=n+1;i<l;i++)						for(i=n+1;i<l;i++)
		alpha[i] = 0;							alpha[i] = 0;

	for(i=0;i<l;i++)						for(i=0;i<l;i++)
	{								{
		zeros[i] = 0;							zeros[i] = 0;
		ones[i] = 1;							ones[i] = 1;
	}								}

	Solver s;							Solver s;
	s.Solve(l, ONE_CLASS_Q(*prob,*param), zeros, ones,		s.Solve(l, ONE_CLASS_Q(*prob,*param), zeros, ones,
		alpha, 1.0, 1.0, param->eps, si, param->shrin			alpha, 1.0, 1.0, param->eps, si, param->shrin

	delete[] zeros;							delete[] zeros;
	delete[] ones;							delete[] ones;
}								}

static void solve_epsilon_svr(					static void solve_epsilon_svr(
	const svm_problem *prob, const svm_parameter *param,		const svm_problem *prob, const svm_parameter *param,
	double *alpha, Solver::SolutionInfo* si)			double *alpha, Solver::SolutionInfo* si)
{								{
	int l = prob->l;						int l = prob->l;
	double *alpha2 = new double[2*l];				double *alpha2 = new double[2*l];
	double *linear_term = new double[2*l];				double *linear_term = new double[2*l];
	schar *y = new schar[2*l];					schar *y = new schar[2*l];
	int i;								int i;

	for(i=0;i<l;i++)						for(i=0;i<l;i++)
	{								{
		alpha2[i] = 0;							alpha2[i] = 0;
		linear_term[i] = param->p - prob->y[i];				linear_term[i] = param->p - prob->y[i];
		y[i] = 1;							y[i] = 1;

		alpha2[i+l] = 0;						alpha2[i+l] = 0;
		linear_term[i+l] = param->p + prob->y[i];			linear_term[i+l] = param->p + prob->y[i];
		y[i+l] = -1;							y[i+l] = -1;
	}								}

	Solver s;							Solver s;
	s.Solve(2*l, SVR_Q(*prob,*param), linear_term, y,		s.Solve(2*l, SVR_Q(*prob,*param), linear_term, y,
		alpha2, param->C, param->C, param->eps, si, p			alpha2, param->C, param->C, param->eps, si, p

	double sum_alpha = 0;						double sum_alpha = 0;
	for(i=0;i<l;i++)						for(i=0;i<l;i++)
	{								{
		alpha[i] = alpha2[i] - alpha2[i+l];				alpha[i] = alpha2[i] - alpha2[i+l];
		sum_alpha += fabs(alpha[i]);					sum_alpha += fabs(alpha[i]);
	}								}
	info("nu = %f\n",sum_alpha/(param->C*l));			info("nu = %f\n",sum_alpha/(param->C*l));

	delete[] alpha2;						delete[] alpha2;
	delete[] linear_term;						delete[] linear_term;
	delete[] y;							delete[] y;
}								}

static void solve_nu_svr(					static void solve_nu_svr(
	const svm_problem *prob, const svm_parameter *param,		const svm_problem *prob, const svm_parameter *param,
	double *alpha, Solver::SolutionInfo* si)			double *alpha, Solver::SolutionInfo* si)
{								{
	if(param->nu < 0 || param->nu > 1)		      <
	{						      <
		fprintf(stderr,"specified nu is out of range\ <
		exit(1);				      <
	}						      <
							      <
	int l = prob->l;						int l = prob->l;
	double C = param->C;						double C = param->C;
	double *alpha2 = new double[2*l];				double *alpha2 = new double[2*l];
	double *linear_term = new double[2*l];				double *linear_term = new double[2*l];
	schar *y = new schar[2*l];					schar *y = new schar[2*l];
	int i;								int i;

	double sum = C * param->nu * l / 2;				double sum = C * param->nu * l / 2;
	for(i=0;i<l;i++)						for(i=0;i<l;i++)
	{								{
		alpha2[i] = alpha2[i+l] = min(sum,C);				alpha2[i] = alpha2[i+l] = min(sum,C);
		sum -= alpha2[i];						sum -= alpha2[i];

		linear_term[i] = - prob->y[i];					linear_term[i] = - prob->y[i];
		y[i] = 1;							y[i] = 1;

		linear_term[i+l] = prob->y[i];					linear_term[i+l] = prob->y[i];
		y[i+l] = -1;							y[i+l] = -1;
	}								}

	Solver_NU s;							Solver_NU s;
	s.Solve(2*l, SVR_Q(*prob,*param), linear_term, y,		s.Solve(2*l, SVR_Q(*prob,*param), linear_term, y,
		alpha2, C, C, param->eps, si, param->shrinkin			alpha2, C, C, param->eps, si, param->shrinkin

	info("epsilon = %f\n",-si->r);					info("epsilon = %f\n",-si->r);

	for(i=0;i<l;i++)						for(i=0;i<l;i++)
		alpha[i] = alpha2[i] - alpha2[i+l];				alpha[i] = alpha2[i] - alpha2[i+l];

	delete[] alpha2;						delete[] alpha2;
	delete[] linear_term;						delete[] linear_term;
	delete[] y;							delete[] y;
}								}

//								//
// decision_function						// decision_function
//								//
struct decision_function					struct decision_function
{								{
	double *alpha;							double *alpha;
	double rho;					      |		double rho;
};								};

decision_function svm_train_one(			      |	static decision_function svm_train_one(
	const svm_problem *prob, const svm_parameter *param,		const svm_problem *prob, const svm_parameter *param,
	double Cp, double Cn)						double Cp, double Cn)
{								{
	double *alpha = Malloc(double,prob->l);				double *alpha = Malloc(double,prob->l);
	Solver::SolutionInfo si;					Solver::SolutionInfo si;
	switch(param->svm_type)						switch(param->svm_type)
	{								{
		case C_SVC:							case C_SVC:
		      solve_c_svc(prob,param,alpha,&si,Cp,Cn) |				solve_c_svc(prob,param,alpha,&si,Cp,C
		      break;				      |				break;
		case RSVMEQ:				      <
		      solve_rsvmeq(prob,param,alpha,&si,Cp,Cn <
		      break;				      <
		case RSVMLSVM:				      <
		      solve_rsvmlsvm(prob,param,alpha,&si,Cp, <
		      break;				      <
		case RSVMEQ2:				      <
		      solve_rsvmeq(prob,param,alpha,&si,Cp,Cn <
		      break;				      <
		case RSVMSSVM:				      <
		      solve_rsvmssvm(prob,param,alpha,&si,Cp, <
		      break;				      <
		case RSVMSSVM1:				      <
		      solve_rsvmeq(prob,param,alpha,&si,Cp,Cn <
		      break;				      <
		case NU_SVC:							case NU_SVC:
		      solve_nu_svc(prob,param,alpha,&si);     |				solve_nu_svc(prob,param,alpha,&si);
		      break;				      |				break;
		case ONE_CLASS:							case ONE_CLASS:
		      solve_one_class(prob,param,alpha,&si);  |				solve_one_class(prob,param,alpha,&si)
							      |				break;
		      break;				      <
		case EPSILON_SVR:						case EPSILON_SVR:
			solve_epsilon_svr(prob,param,alpha,&s				solve_epsilon_svr(prob,param,alpha,&s
			break;								break;
		case NU_SVR:							case NU_SVR:
			solve_nu_svr(prob,param,alpha,&si);				solve_nu_svr(prob,param,alpha,&si);
			break;								break;
	}								}

	info("obj = %f, rho = %f\n",si.obj,si.rho);			info("obj = %f, rho = %f\n",si.obj,si.rho);

	// output SVs							// output SVs

	int nSV = 0;							int nSV = 0;
	int nBSV = 0;							int nBSV = 0;
	for(int i=0;i<prob->l;i++)					for(int i=0;i<prob->l;i++)
	{								{
		if(fabs(alpha[i]) > 0)						if(fabs(alpha[i]) > 0)
		{								{
			++nSV;								++nSV;
			if(prob->y[i] > 0)						if(prob->y[i] > 0)
			{								{
				if(fabs(alpha[i]) >= si.upper					if(fabs(alpha[i]) >= si.upper
					++nBSV;								++nBSV;
			}								}
			else								else
			{								{
				if(fabs(alpha[i]) >= si.upper					if(fabs(alpha[i]) >= si.upper
					++nBSV;								++nBSV;
			}								}
		}								}
	}								}

	info("nSV = %d, nBSV = %d\n",nSV,nBSV);				info("nSV = %d, nBSV = %d\n",nSV,nBSV);

	decision_function f;						decision_function f;
	f.alpha = alpha;						f.alpha = alpha;
	f.rho = si.rho;							f.rho = si.rho;
	return f;							return f;
}								}

//							      |	// Platt's binary SVM Probablistic Output: an improvement fro
// svm_model						      |	static void sigmoid_train(
//							      |		int l, const double *dec_values, const double *labels
struct svm_model					      |		double& A, double& B)
{								{
	svm_parameter param;	// parameter		      |		double prior1=0, prior0 = 0;
	int nr_class;		// number of classes, = 2 in  |		int i;
	int l;			// total #SV		      |
	svm_node **SV;		// SVs (SV[l])		      |		for (i=0;i<l;i++)
	double **sv_coef;	// coefficients for SVs in de |			if (labels[i] > 0) prior1+=1;
	double *rho;		// constants in decision func |			else prior0+=1;
							      |		
	// for classification only			      |		int max_iter=100;	// Maximal number of iteratio
							      |		double min_step=1e-10;	// Minimal step taken in line
	int *label;		// label of each class (label |		double sigma=1e-12;	// For numerically strict PD 
	int *nSV;		// number of SVs for each cla |		double eps=1e-5;
				// nSV[0] + nSV[1] + ... + nS |		double hiTarget=(prior1+1.0)/(prior1+2.0);
	// XXX						      |		double loTarget=1/(prior0+2.0);
	int free_sv;		// 1 if svm_model is created  |		double *t=Malloc(double,l);
				// 0 if svm_model is created  |		double fApB,p,q,h11,h22,h21,g1,g2,det,dA,dB,gd,stepsi
};							      |		double newA,newB,newf,d1,d2;
							      >		int iter;
							      >		
							      >		// Initial Point and Initial Fun Value
							      >		A=0.0; B=log((prior0+1.0)/(prior1+1.0));
							      >		double fval = 0.0;
							      >
							      >		for (i=0;i<l;i++)
							      >		{
							      >			if (labels[i]>0) t[i]=hiTarget;
							      >			else t[i]=loTarget;
							      >			fApB = dec_values[i]*A+B;
							      >			if (fApB>=0)
							      >				fval += t[i]*fApB + log(1+exp(-fApB))
							      >			else
							      >				fval += (t[i] - 1)*fApB +log(1+exp(fA
							      >		}
							      >		for (iter=0;iter<max_iter;iter++)
							      >		{
							      >			// Update Gradient and Hessian (use H' = H + 
							      >			h11=sigma; // numerically ensures strict PD
							      >			h22=sigma;
							      >			h21=0.0;g1=0.0;g2=0.0;
							      >			for (i=0;i<l;i++)
							      >			{
							      >				fApB = dec_values[i]*A+B;
							      >				if (fApB >= 0)
							      >				{
							      >					p=exp(-fApB)/(1.0+exp(-fApB))
							      >					q=1.0/(1.0+exp(-fApB));
							      >				}
							      >				else
							      >				{
							      >					p=1.0/(1.0+exp(fApB));
							      >					q=exp(fApB)/(1.0+exp(fApB));
							      >				}
							      >				d2=p*q;
							      >				h11+=dec_values[i]*dec_values[i]*d2;
							      >				h22+=d2;
							      >				h21+=dec_values[i]*d2;
							      >				d1=t[i]-p;
							      >				g1+=dec_values[i]*d1;
							      >				g2+=d1;
							      >			}
							      >
							      >			// Stopping Criteria
							      >			if (fabs(g1)<eps && fabs(g2)<eps)
							      >				break;
							      >
							      >			// Finding Newton direction: -inv(H') * g
							      >			det=h11*h22-h21*h21;
							      >			dA=-(h22*g1 - h21 * g2) / det;
							      >			dB=-(-h21*g1+ h11 * g2) / det;
							      >			gd=g1*dA+g2*dB;
							      >
							      >
							      >			stepsize = 1;		// Line Search
							      >			while (stepsize >= min_step)
							      >			{
							      >				newA = A + stepsize * dA;
							      >				newB = B + stepsize * dB;
							      >
							      >				// New function value
							      >				newf = 0.0;
							      >				for (i=0;i<l;i++)
							      >				{
							      >					fApB = dec_values[i]*newA+new
							      >					if (fApB >= 0)
							      >						newf += t[i]*fApB + l
							      >					else
							      >						newf += (t[i] - 1)*fA
							      >				}
							      >				// Check sufficient decrease
							      >				if (newf<fval+0.0001*stepsize*gd)
							      >				{
							      >					A=newA;B=newB;fval=newf;
							      >					break;
							      >				}
							      >				else
							      >					stepsize = stepsize / 2.0;
							      >			}
							      >
							      >			if (stepsize < min_step)
							      >			{
							      >				info("Line search fails in two-class 
							      >				break;
							      >			}
							      >		}
							      >
							      >		if (iter>=max_iter)
							      >			info("Reaching maximal iterations in two-clas
							      >		free(t);
							      >	}
							      >
							      >	static double sigmoid_predict(double decision_value, double A
							      >	{
							      >		double fApB = decision_value*A+B;
							      >		// 1-p used later; avoid catastrophic cancellation
							      >		if (fApB >= 0)
							      >			return exp(-fApB)/(1.0+exp(-fApB));
							      >		else
							      >			return 1.0/(1+exp(fApB)) ;
							      >	}
							      >
							      >	// Method 2 from the multiclass_prob paper by Wu, Lin, and We
							      >	static void multiclass_probability(int k, double **r, double 
							      >	{
							      >		int t,j;
							      >		int iter = 0, max_iter=max(100,k);
							      >		double **Q=Malloc(double *,k);
							      >		double *Qp=Malloc(double,k);
							      >		double pQp, eps=0.005/k;
							      >		
							      >		for (t=0;t<k;t++)
							      >		{
							      >			p[t]=1.0/k;  // Valid if k = 1
							      >			Q[t]=Malloc(double,k);
							      >			Q[t][t]=0;
							      >			for (j=0;j<t;j++)
							      >			{
							      >				Q[t][t]+=r[j][t]*r[j][t];
							      >				Q[t][j]=Q[j][t];
							      >			}
							      >			for (j=t+1;j<k;j++)
							      >			{
							      >				Q[t][t]+=r[j][t]*r[j][t];
							      >				Q[t][j]=-r[j][t]*r[t][j];
							      >			}
							      >		}
							      >		for (iter=0;iter<max_iter;iter++)
							      >		{
							      >			// stopping condition, recalculate QP,pQP for
							      >			pQp=0;
							      >			for (t=0;t<k;t++)
							      >			{
							      >				Qp[t]=0;
							      >				for (j=0;j<k;j++)
							      >					Qp[t]+=Q[t][j]*p[j];
							      >				pQp+=p[t]*Qp[t];
							      >			}
							      >			double max_error=0;
							      >			for (t=0;t<k;t++)
							      >			{
							      >				double error=fabs(Qp[t]-pQp);
							      >				if (error>max_error)
							      >					max_error=error;
							      >			}
							      >			if (max_error<eps) break;
							      >			
							      >			for (t=0;t<k;t++)
							      >			{
							      >				double diff=(-Qp[t]+pQp)/Q[t][t];
							      >				p[t]+=diff;
							      >				pQp=(pQp+diff*(diff*Q[t][t]+2*Qp[t]))
							      >				for (j=0;j<k;j++)
							      >				{
							      >					Qp[j]=(Qp[j]+diff*Q[t][j])/(1
							      >					p[j]/=(1+diff);
							      >				}
							      >			}
							      >		}
							      >		if (iter>=max_iter)
							      >			info("Exceeds max_iter in multiclass_prob\n")
							      >		for(t=0;t<k;t++) free(Q[t]);
							      >		free(Q);
							      >		free(Qp);
							      >	}
							      >
							      >	// Cross-validation decision values for probability estimates
							      >	static void svm_binary_svc_probability(
							      >		const svm_problem *prob, const svm_parameter *param,
							      >		double Cp, double Cn, double& probA, double& probB)
							      >	{
							      >		int i;
							      >		int nr_fold = 5;
							      >		int *perm = Malloc(int,prob->l);
							      >		double *dec_values = Malloc(double,prob->l);
							      >
							      >		// random shuffle
							      >		for(i=0;i<prob->l;i++) perm[i]=i;
							      >		for(i=0;i<prob->l;i++)
							      >		{
							      >			int j = i+rand()%(prob->l-i);
							      >			swap(perm[i],perm[j]);
							      >		}
							      >		for(i=0;i<nr_fold;i++)
							      >		{
							      >			int begin = i*prob->l/nr_fold;
							      >			int end = (i+1)*prob->l/nr_fold;
							      >			int j,k;
							      >			struct svm_problem subprob;
							      >
							      >			subprob.l = prob->l-(end-begin);
							      >			subprob.x = Malloc(struct svm_node*,subprob.l
							      >			subprob.y = Malloc(double,subprob.l);
							      >				
							      >			k=0;
							      >			for(j=0;j<begin;j++)
							      >			{
							      >				subprob.x[k] = prob->x[perm[j]];
							      >				subprob.y[k] = prob->y[perm[j]];
							      >				++k;
							      >			}
							      >			for(j=end;j<prob->l;j++)
							      >			{
							      >				subprob.x[k] = prob->x[perm[j]];
							      >				subprob.y[k] = prob->y[perm[j]];
							      >				++k;
							      >			}
							      >			int p_count=0,n_count=0;
							      >			for(j=0;j<k;j++)
							      >				if(subprob.y[j]>0)
							      >					p_count++;
							      >				else
							      >					n_count++;
							      >
							      >			if(p_count==0 && n_count==0)
							      >				for(j=begin;j<end;j++)
							      >					dec_values[perm[j]] = 0;
							      >			else if(p_count > 0 && n_count == 0)
							      >				for(j=begin;j<end;j++)
							      >					dec_values[perm[j]] = 1;
							      >			else if(p_count == 0 && n_count > 0)
							      >				for(j=begin;j<end;j++)
							      >					dec_values[perm[j]] = -1;
							      >			else
							      >			{
							      >				svm_parameter subparam = *param;
							      >				subparam.probability=0;
							      >				subparam.C=1.0;
							      >				subparam.nr_weight=2;
							      >				subparam.weight_label = Malloc(int,2)
							      >				subparam.weight = Malloc(double,2);
							      >				subparam.weight_label[0]=+1;
							      >				subparam.weight_label[1]=-1;
							      >				subparam.weight[0]=Cp;
							      >				subparam.weight[1]=Cn;
							      >				struct svm_model *submodel = svm_trai
							      >				for(j=begin;j<end;j++)
							      >				{
							      >					svm_predict_values(submodel,p
							      >					// ensure +1 -1 order; reason
							      >					dec_values[perm[j]] *= submod
							      >				}		
							      >				svm_free_and_destroy_model(&submodel)
							      >				svm_destroy_param(&subparam);
							      >			}
							      >			free(subprob.x);
							      >			free(subprob.y);
							      >		}		
							      >		sigmoid_train(prob->l,dec_values,prob->y,probA,probB)
							      >		free(dec_values);
							      >		free(perm);
							      >	}
							      >
							      >	// Return parameter of a Laplace distribution 
							      >	static double svm_svr_probability(
							      >		const svm_problem *prob, const svm_parameter *param)
							      >	{
							      >		int i;
							      >		int nr_fold = 5;
							      >		double *ymv = Malloc(double,prob->l);
							      >		double mae = 0;
							      >
							      >		svm_parameter newparam = *param;
							      >		newparam.probability = 0;
							      >		svm_cross_validation(prob,&newparam,nr_fold,ymv);
							      >		for(i=0;i<prob->l;i++)
							      >		{
							      >			ymv[i]=prob->y[i]-ymv[i];
							      >			mae += fabs(ymv[i]);
							      >		}		
							      >		mae /= prob->l;
							      >		double std=sqrt(2*mae*mae);
							      >		int count=0;
							      >		mae=0;
							      >		for(i=0;i<prob->l;i++)
							      >			if (fabs(ymv[i]) > 5*std) 
							      >				count=count+1;
							      >			else 
							      >				mae+=fabs(ymv[i]);
							      >		mae /= (prob->l-count);
							      >		info("Prob. model for test data: target value = predi
							      >		free(ymv);
							      >		return mae;
							      >	}
							      >
							      >
							      >	// label: label name, start: begin of each class, count: #dat
							      >	// perm, length l, must be allocated before calling this subr
							      >	static void svm_group_classes(const svm_problem *prob, int *n
							      >	{
							      >		int l = prob->l;
							      >		int max_nr_class = 16;
							      >		int nr_class = 0;
							      >		int *label = Malloc(int,max_nr_class);
							      >		int *count = Malloc(int,max_nr_class);
							      >		int *data_label = Malloc(int,l);
							      >		int i;
							      >
							      >		for(i=0;i<l;i++)
							      >		{
							      >			int this_label = (int)prob->y[i];
							      >			int j;
							      >			for(j=0;j<nr_class;j++)
							      >			{
							      >				if(this_label == label[j])
							      >				{
							      >					++count[j];
							      >					break;
							      >				}
							      >			}
							      >			data_label[i] = j;
							      >			if(j == nr_class)
							      >			{
							      >				if(nr_class == max_nr_class)
							      >				{
							      >					max_nr_class *= 2;
							      >					label = (int *)realloc(label,
							      >					count = (int *)realloc(count,
							      >				}
							      >				label[nr_class] = this_label;
							      >				count[nr_class] = 1;
							      >				++nr_class;
							      >			}
							      >		}
							      >
							      >		//
							      >		// Labels are ordered by their first occurrence in th
							      >		// However, for two-class sets with -1/+1 labels and 
							      >		// we swap labels to ensure that internally the binar
							      >		//
							      >		if (nr_class == 2 && label[0] == -1 && label[1] == 1)
							      >		{
							      >			swap(label[0],label[1]);
							      >			swap(count[0],count[1]);
							      >			for(i=0;i<l;i++)
							      >			{
							      >				if(data_label[i] == 0)
							      >					data_label[i] = 1;
							      >				else
							      >					data_label[i] = 0;
							      >			}
							      >		}
							      >
							      >		int *start = Malloc(int,nr_class);
							      >		start[0] = 0;
							      >		for(i=1;i<nr_class;i++)
							      >			start[i] = start[i-1]+count[i-1];
							      >		for(i=0;i<l;i++)
							      >		{
							      >			perm[start[data_label[i]]] = i;
							      >			++start[data_label[i]];
							      >		}
							      >		start[0] = 0;
							      >		for(i=1;i<nr_class;i++)
							      >			start[i] = start[i-1]+count[i-1];
							      >
							      >		*nr_class_ret = nr_class;
							      >		*label_ret = label;
							      >		*start_ret = start;
							      >		*count_ret = count;
							      >		free(data_label);
							      >	}

//								//
// Interface functions						// Interface functions
//								//
svm_model *svm_train(const svm_problem *prob, const svm_param	svm_model *svm_train(const svm_problem *prob, const svm_param
{								{
	svm_model *model = Malloc(svm_model,1);				svm_model *model = Malloc(svm_model,1);
	model->param = *param;						model->param = *param;
	model->free_sv = 0;	// XXX					model->free_sv = 0;	// XXX

	if(param->svm_type == ONE_CLASS ||				if(param->svm_type == ONE_CLASS ||
	   param->svm_type == EPSILON_SVR ||				   param->svm_type == EPSILON_SVR ||
	   param->svm_type == NU_SVR)					   param->svm_type == NU_SVR)
	{								{
		// regression or one-class-svm					// regression or one-class-svm
		model->nr_class = 2;						model->nr_class = 2;
		model->label = NULL;						model->label = NULL;
		model->nSV = NULL;						model->nSV = NULL;
							      >			model->probA = NULL; model->probB = NULL;
		model->sv_coef = Malloc(double *,1);				model->sv_coef = Malloc(double *,1);
							      >
							      >			if(param->probability && 
							      >			   (param->svm_type == EPSILON_SVR ||
							      >			    param->svm_type == NU_SVR))
							      >			{
							      >				model->probA = Malloc(double,1);
							      >				model->probA[0] = svm_svr_probability
							      >			}
							      >
		decision_function f = svm_train_one(prob,para			decision_function f = svm_train_one(prob,para
		model->rho = Malloc(double,1);					model->rho = Malloc(double,1);
		model->rho[0] = f.rho;						model->rho[0] = f.rho;

		int nSV = 0;							int nSV = 0;
		int i;								int i;
		for(i=0;i<prob->l;i++)						for(i=0;i<prob->l;i++)
			if(fabs(f.alpha[i]) > 0) ++nSV;					if(fabs(f.alpha[i]) > 0) ++nSV;
		model->l = nSV;							model->l = nSV;
		model->SV = Malloc(svm_node *,nSV);				model->SV = Malloc(svm_node *,nSV);
		model->sv_coef[0] = Malloc(double,nSV);				model->sv_coef[0] = Malloc(double,nSV);
							      >			model->sv_indices = Malloc(int,nSV);
		int j = 0;							int j = 0;
		for(i=0;i<prob->l;i++)						for(i=0;i<prob->l;i++)
			if(fabs(f.alpha[i]) > 0)					if(fabs(f.alpha[i]) > 0)
			{								{
				model->SV[j] = prob->x[i];					model->SV[j] = prob->x[i];
				model->sv_coef[0][j] = f.alph					model->sv_coef[0][j] = f.alph
							      >					model->sv_indices[j] = i+1;
				++j;								++j;
			}								}		

		free(f.alpha);							free(f.alpha);
	}								}
	else								else
	{								{
		// classification						// classification
		// find out the number of classes	      <
		int l = prob->l;						int l = prob->l;
		int max_nr_class = 16;			      |			int nr_class;
		int nr_class = 0;			      |			int *label = NULL;
		int *label = Malloc(int,max_nr_class);	      |			int *start = NULL;
		int *count = Malloc(int,max_nr_class);	      |			int *count = NULL;
		int *index = Malloc(int,l);		      |			int *perm = Malloc(int,l);
							      <
		mytime = 0;				      <
							      <
		int i;					      <
		for(i=0;i<l;i++)			      <
		{					      <
			int this_label = (int)prob->y[i];     <
			int j;				      <
			for(j=0;j<nr_class;j++)		      <
				if(this_label == label[j])    <
				{			      <
					++count[j];	      <
					break;		      <
				}			      <
			index[i] = j;			      <
			if(j == nr_class)		      <
			{				      <
				if(nr_class == max_nr_class)  <
				{			      <
					max_nr_class *= 2;    <
					label = (int *)reallo <
					count = (int *)reallo <
				}			      <
				label[nr_class] = this_label; <
				count[nr_class] = 1;	      <
				++nr_class;		      <
			}				      <
		}					      <

		// group training data of the same class			// group training data of the same class
							      |			svm_group_classes(prob,&nr_class,&label,&star
		int *start = Malloc(int,nr_class);	      |			if(nr_class == 1) 
		start[0] = 0;				      |				info("WARNING: training data in only 
		for(i=1;i<nr_class;i++)			      <
			start[i] = start[i-1]+count[i-1];     <
							      <
		svm_node **x = Malloc(svm_node *,l);	      <
										
							      >			svm_node **x = Malloc(svm_node *,l);
							      >			int i;
		for(i=0;i<l;i++)						for(i=0;i<l;i++)
		{					      |				x[i] = prob->x[perm[i]];
			x[start[index[i]]] = prob->x[i];      <
			++start[index[i]];		      <
		}					      <
							      <
		start[0] = 0;				      <
		for(i=1;i<nr_class;i++)			      <
			start[i] = start[i-1]+count[i-1];     <

		// calculate weighted C						// calculate weighted C

		double *weighted_C = Malloc(double, nr_class)			double *weighted_C = Malloc(double, nr_class)
		for(i=0;i<nr_class;i++)						for(i=0;i<nr_class;i++)
			weighted_C[i] = param->C;					weighted_C[i] = param->C;
		for(i=0;i<param->nr_weight;i++)					for(i=0;i<param->nr_weight;i++)
		{								{	
			int j;								int j;
			for(j=0;j<nr_class;j++)						for(j=0;j<nr_class;j++)
				if(param->weight_label[i] == 					if(param->weight_label[i] == 
					break;								break;
			if(j == nr_class)						if(j == nr_class)
				fprintf(stderr,"warning: clas |					fprintf(stderr,"WARNING: clas
			else								else
				weighted_C[j] *= param->weigh					weighted_C[j] *= param->weigh
		}								}

		// train n*(n-1)/2 models		      |			// train k*(k-1)/2 models
										
		bool *nonzero = Malloc(bool,l);					bool *nonzero = Malloc(bool,l);
		for(i=0;i<l;i++)						for(i=0;i<l;i++)
			nonzero[i] = false;						nonzero[i] = false;
		decision_function *f = Malloc(decision_functi			decision_function *f = Malloc(decision_functi

							      >			double *probA=NULL,*probB=NULL;
							      >			if (param->probability)
							      >			{
							      >				probA=Malloc(double,nr_class*(nr_clas
							      >				probB=Malloc(double,nr_class*(nr_clas
							      >			}
							      >
		int p = 0;							int p = 0;
		for(i=0;i<nr_class;i++)						for(i=0;i<nr_class;i++)
			for(int j=i+1;j<nr_class;j++)					for(int j=i+1;j<nr_class;j++)
			{								{
				svm_problem sub_prob;						svm_problem sub_prob;
				int si = start[i], sj = start					int si = start[i], sj = start
				int ci = count[i], cj = count					int ci = count[i], cj = count
				sub_prob.l = ci+cj;						sub_prob.l = ci+cj;
				sub_prob.x = Malloc(svm_node 					sub_prob.x = Malloc(svm_node 
				sub_prob.y = Malloc(double,su					sub_prob.y = Malloc(double,su
				int k;								int k;
				for(k=0;k<ci;k++)						for(k=0;k<ci;k++)
				{								{
					sub_prob.x[k] = x[si+						sub_prob.x[k] = x[si+
					sub_prob.y[k] = +1;						sub_prob.y[k] = +1;
				}								}
				for(k=0;k<cj;k++)						for(k=0;k<cj;k++)
				{								{
					sub_prob.x[ci+k] = x[						sub_prob.x[ci+k] = x[
					sub_prob.y[ci+k] = -1						sub_prob.y[ci+k] = -1
				}								}
							      |
							      >					if(param->probability)
							      >						svm_binary_svc_probab
							      >
				f[p] = svm_train_one(&sub_pro					f[p] = svm_train_one(&sub_pro
				for(k=0;k<ci;k++)						for(k=0;k<ci;k++)
					if(!nonzero[si+k] && 						if(!nonzero[si+k] && 
						nonzero[si+k]							nonzero[si+k]
				for(k=0;k<cj;k++)						for(k=0;k<cj;k++)
					if(!nonzero[sj+k] && 						if(!nonzero[sj+k] && 
						nonzero[sj+k]							nonzero[sj+k]
				free(sub_prob.x);						free(sub_prob.x);
				free(sub_prob.y);						free(sub_prob.y);
				++p;								++p;
			}								}

		// build output							// build output

		model->nr_class = nr_class;					model->nr_class = nr_class;
										
		model->label = Malloc(int,nr_class);				model->label = Malloc(int,nr_class);
		for(i=0;i<nr_class;i++)						for(i=0;i<nr_class;i++)
			model->label[i] = label[i];					model->label[i] = label[i];
										
		model->rho = Malloc(double,nr_class*(nr_class			model->rho = Malloc(double,nr_class*(nr_class
		for(i=0;i<nr_class*(nr_class-1)/2;i++)				for(i=0;i<nr_class*(nr_class-1)/2;i++)
			model->rho[i] = f[i].rho;					model->rho[i] = f[i].rho;

							      >			if(param->probability)
							      >			{
							      >				model->probA = Malloc(double,nr_class
							      >				model->probB = Malloc(double,nr_class
							      >				for(i=0;i<nr_class*(nr_class-1)/2;i++
							      >				{
							      >					model->probA[i] = probA[i];
							      >					model->probB[i] = probB[i];
							      >				}
							      >			}
							      >			else
							      >			{
							      >				model->probA=NULL;
							      >				model->probB=NULL;
							      >			}
							      >
		int total_sv = 0;						int total_sv = 0;
		int *nz_count = Malloc(int,nr_class);				int *nz_count = Malloc(int,nr_class);
		model->nSV = Malloc(int,nr_class);				model->nSV = Malloc(int,nr_class);
		for(i=0;i<nr_class;i++)						for(i=0;i<nr_class;i++)
		{								{
			int nSV = 0;							int nSV = 0;
			for(int j=0;j<count[i];j++)					for(int j=0;j<count[i];j++)
				if(nonzero[start[i]+j])						if(nonzero[start[i]+j])
				{								{	
					++nSV;								++nSV;
					++total_sv;							++total_sv;
				}								}
			model->nSV[i] = nSV;						model->nSV[i] = nSV;
			nz_count[i] = nSV;						nz_count[i] = nSV;
		}								}
										
		info("Total nSV = %d\n",total_sv);				info("Total nSV = %d\n",total_sv);
		double CLK_TCK=1000.0;			      <
		info("Selection time = %f\n",(double)mytime/C <

		model->l = total_sv;						model->l = total_sv;
		model->SV = Malloc(svm_node *,total_sv);			model->SV = Malloc(svm_node *,total_sv);
							      >			model->sv_indices = Malloc(int,total_sv);
		p = 0;								p = 0;
		for(i=0;i<l;i++)						for(i=0;i<l;i++)
			if(nonzero[i]) model->SV[p++] = x[i]; |				if(nonzero[i])
							      >				{
							      >					model->SV[p] = x[i];
							      >					model->sv_indices[p++] = perm
							      >				}

		int *nz_start = Malloc(int,nr_class);				int *nz_start = Malloc(int,nr_class);
		nz_start[0] = 0;						nz_start[0] = 0;
		for(i=1;i<nr_class;i++)						for(i=1;i<nr_class;i++)
			nz_start[i] = nz_start[i-1]+nz_count[				nz_start[i] = nz_start[i-1]+nz_count[

		model->sv_coef = Malloc(double *,nr_class-1);			model->sv_coef = Malloc(double *,nr_class-1);
		for(i=0;i<nr_class-1;i++)					for(i=0;i<nr_class-1;i++)
			model->sv_coef[i] = Malloc(double,tot				model->sv_coef[i] = Malloc(double,tot

		p = 0;								p = 0;
		for(i=0;i<nr_class;i++)						for(i=0;i<nr_class;i++)
			for(int j=i+1;j<nr_class;j++)					for(int j=i+1;j<nr_class;j++)
			{								{
				// classifier (i,j): coeffici					// classifier (i,j): coeffici
				// i are in sv_coef[j-1][nz_s					// i are in sv_coef[j-1][nz_s
				// j are in sv_coef[i][nz_sta					// j are in sv_coef[i][nz_sta

				int si = start[i];						int si = start[i];
				int sj = start[j];						int sj = start[j];
				int ci = count[i];						int ci = count[i];
				int cj = count[j];						int cj = count[j];
												
				int q = nz_start[i];						int q = nz_start[i];
				int k;								int k;
				for(k=0;k<ci;k++)						for(k=0;k<ci;k++)
					if(nonzero[si+k])						if(nonzero[si+k])
						model->sv_coe							model->sv_coe
				q = nz_start[j];						q = nz_start[j];
				for(k=0;k<cj;k++)						for(k=0;k<cj;k++)
					if(nonzero[sj+k])						if(nonzero[sj+k])
						model->sv_coe							model->sv_coe
				++p;								++p;
			}								}
										
		free(label);							free(label);
							      >			free(probA);
							      >			free(probB);
		free(count);							free(count);
		free(index);				      |			free(perm);
		free(start);							free(start);
		free(x);							free(x);
		free(weighted_C);						free(weighted_C);
		free(nonzero);							free(nonzero);
		for(i=0;i<nr_class*(nr_class-1)/2;i++)				for(i=0;i<nr_class*(nr_class-1)/2;i++)
			free(f[i].alpha);						free(f[i].alpha);
		free(f);							free(f);
		free(nz_count);							free(nz_count);
		free(nz_start);							free(nz_start);
	}								}
	return model;							return model;
}								}

double svm_predict(const svm_model *model, const svm_node *x) |	// Stratified cross validation
							      >	void svm_cross_validation(const svm_problem *prob, const svm_
							      >	{
							      >		int i;
							      >		int *fold_start;
							      >		int l = prob->l;
							      >		int *perm = Malloc(int,l);
							      >		int nr_class;
							      >		if (nr_fold > l)
							      >		{
							      >			nr_fold = l;
							      >			fprintf(stderr,"WARNING: # folds > # data. Wi
							      >		}
							      >		fold_start = Malloc(int,nr_fold+1);
							      >		// stratified cv may not give leave-one-out rate
							      >		// Each class to l folds -> some folds may have zero 
							      >		if((param->svm_type == C_SVC ||
							      >		    param->svm_type == NU_SVC) && nr_fold < l)
							      >		{
							      >			int *start = NULL;
							      >			int *label = NULL;
							      >			int *count = NULL;
							      >			svm_group_classes(prob,&nr_class,&label,&star
							      >
							      >			// random shuffle and then data grouped by fo
							      >			int *fold_count = Malloc(int,nr_fold);
							      >			int c;
							      >			int *index = Malloc(int,l);
							      >			for(i=0;i<l;i++)
							      >				index[i]=perm[i];
							      >			for (c=0; c<nr_class; c++) 
							      >				for(i=0;i<count[c];i++)
							      >				{
							      >					int j = i+rand()%(count[c]-i)
							      >					swap(index[start[c]+j],index[
							      >				}
							      >			for(i=0;i<nr_fold;i++)
							      >			{
							      >				fold_count[i] = 0;
							      >				for (c=0; c<nr_class;c++)
							      >					fold_count[i]+=(i+1)*count[c]
							      >			}
							      >			fold_start[0]=0;
							      >			for (i=1;i<=nr_fold;i++)
							      >				fold_start[i] = fold_start[i-1]+fold_
							      >			for (c=0; c<nr_class;c++)
							      >				for(i=0;i<nr_fold;i++)
							      >				{
							      >					int begin = start[c]+i*count[
							      >					int end = start[c]+(i+1)*coun
							      >					for(int j=begin;j<end;j++)
							      >					{
							      >						perm[fold_start[i]] =
							      >						fold_start[i]++;
							      >					}
							      >				}
							      >			fold_start[0]=0;
							      >			for (i=1;i<=nr_fold;i++)
							      >				fold_start[i] = fold_start[i-1]+fold_
							      >			free(start);
							      >			free(label);
							      >			free(count);
							      >			free(index);
							      >			free(fold_count);
							      >		}
							      >		else
							      >		{
							      >			for(i=0;i<l;i++) perm[i]=i;
							      >			for(i=0;i<l;i++)
							      >			{
							      >				int j = i+rand()%(l-i);
							      >				swap(perm[i],perm[j]);
							      >			}
							      >			for(i=0;i<=nr_fold;i++)
							      >				fold_start[i]=i*l/nr_fold;
							      >		}
							      >
							      >		for(i=0;i<nr_fold;i++)
							      >		{
							      >			int begin = fold_start[i];
							      >			int end = fold_start[i+1];
							      >			int j,k;
							      >			struct svm_problem subprob;
							      >
							      >			subprob.l = l-(end-begin);
							      >			subprob.x = Malloc(struct svm_node*,subprob.l
							      >			subprob.y = Malloc(double,subprob.l);
							      >				
							      >			k=0;
							      >			for(j=0;j<begin;j++)
							      >			{
							      >				subprob.x[k] = prob->x[perm[j]];
							      >				subprob.y[k] = prob->y[perm[j]];
							      >				++k;
							      >			}
							      >			for(j=end;j<l;j++)
							      >			{
							      >				subprob.x[k] = prob->x[perm[j]];
							      >				subprob.y[k] = prob->y[perm[j]];
							      >				++k;
							      >			}
							      >			struct svm_model *submodel = svm_train(&subpr
							      >			if(param->probability && 
							      >			   (param->svm_type == C_SVC || param->svm_ty
							      >			{
							      >				double *prob_estimates=Malloc(double,
							      >				for(j=begin;j<end;j++)
							      >					target[perm[j]] = svm_predict
							      >				free(prob_estimates);
							      >			}
							      >			else
							      >				for(j=begin;j<end;j++)
							      >					target[perm[j]] = svm_predict
							      >			svm_free_and_destroy_model(&submodel);
							      >			free(subprob.x);
							      >			free(subprob.y);
							      >		}		
							      >		free(fold_start);
							      >		free(perm);
							      >	}
							      >
							      >
							      >	int svm_get_svm_type(const svm_model *model)
							      >	{
							      >		return model->param.svm_type;
							      >	}
							      >
							      >	int svm_get_nr_class(const svm_model *model)
							      >	{
							      >		return model->nr_class;
							      >	}
							      >
							      >	void svm_get_labels(const svm_model *model, int* label)
							      >	{
							      >		if (model->label != NULL)
							      >			for(int i=0;i<model->nr_class;i++)
							      >				label[i] = model->label[i];
							      >	}
							      >
							      >	void svm_get_sv_indices(const svm_model *model, int* indices)
							      >	{
							      >		if (model->sv_indices != NULL)
							      >			for(int i=0;i<model->l;i++)
							      >				indices[i] = model->sv_indices[i];
							      >	}
							      >
							      >	int svm_get_nr_sv(const svm_model *model)
							      >	{
							      >		return model->l;
							      >	}
							      >
							      >	double svm_get_svr_probability(const svm_model *model)
{								{
							      >		if ((model->param.svm_type == EPSILON_SVR || model->p
							      >		    model->probA!=NULL)
							      >			return model->probA[0];
							      >		else
							      >		{
							      >			fprintf(stderr,"Model doesn't contain informa
							      >			return 0;
							      >		}
							      >	}
							      >
							      >	double svm_predict_values(const svm_model *model, const svm_n
							      >	{
							      >		int i;
	if(model->param.svm_type == ONE_CLASS ||			if(model->param.svm_type == ONE_CLASS ||
	   model->param.svm_type == EPSILON_SVR ||			   model->param.svm_type == EPSILON_SVR ||
	   model->param.svm_type == NU_SVR)				   model->param.svm_type == NU_SVR)
	{								{
		double *sv_coef = model->sv_coef[0];				double *sv_coef = model->sv_coef[0];
		double sum = 0;							double sum = 0;
		for(int i=0;i<model->l;i++)		      |			for(i=0;i<model->l;i++)
			sum += sv_coef[i] * Kernel::k_functio				sum += sv_coef[i] * Kernel::k_functio
		sum -= model->rho[0];						sum -= model->rho[0];
							      >			*dec_values = sum;
							      >
		if(model->param.svm_type == ONE_CLASS)				if(model->param.svm_type == ONE_CLASS)
			return (sum>0)?1:-1;						return (sum>0)?1:-1;
		else								else
			return sum;							return sum;
	}								}
	else								else
	{								{
		int i;					      <
		int nr_class = model->nr_class;					int nr_class = model->nr_class;
		int l = model->l;						int l = model->l;
										
		double *kvalue = Malloc(double,l);				double *kvalue = Malloc(double,l);
		for(i=0;i<l;i++)						for(i=0;i<l;i++)
			kvalue[i] = Kernel::k_function(x,mode				kvalue[i] = Kernel::k_function(x,mode

		int *start = Malloc(int,nr_class);				int *start = Malloc(int,nr_class);
		start[0] = 0;							start[0] = 0;
		for(i=1;i<nr_class;i++)						for(i=1;i<nr_class;i++)
			start[i] = start[i-1]+model->nSV[i-1]				start[i] = start[i-1]+model->nSV[i-1]

		int *vote = Malloc(int,nr_class);				int *vote = Malloc(int,nr_class);
		for(i=0;i<nr_class;i++)						for(i=0;i<nr_class;i++)
			vote[i] = 0;							vote[i] = 0;
							      >
		int p=0;							int p=0;
		for(i=0;i<nr_class;i++)						for(i=0;i<nr_class;i++)
			for(int j=i+1;j<nr_class;j++)					for(int j=i+1;j<nr_class;j++)
			{								{
				double sum = 0;							double sum = 0;
				int si = start[i];						int si = start[i];
				int sj = start[j];						int sj = start[j];
				int ci = model->nSV[i];						int ci = model->nSV[i];
				int cj = model->nSV[j];						int cj = model->nSV[j];
												
				int k;								int k;
				double *coef1 = model->sv_coe					double *coef1 = model->sv_coe
				double *coef2 = model->sv_coe					double *coef2 = model->sv_coe
				for(k=0;k<ci;k++)						for(k=0;k<ci;k++)
					sum += coef1[si+k] * 						sum += coef1[si+k] * 
				for(k=0;k<cj;k++)						for(k=0;k<cj;k++)
					sum += coef2[sj+k] * 						sum += coef2[sj+k] * 
				sum -= model->rho[p++];	      |					sum -= model->rho[p];
				if(sum > 0)		      |					dec_values[p] = sum;
							      >
							      >					if(dec_values[p] > 0)
					++vote[i];							++vote[i];
				else								else
					++vote[j];							++vote[j];
							      >					p++;
			}								}

		int vote_max_idx = 0;						int vote_max_idx = 0;
		for(i=1;i<nr_class;i++)						for(i=1;i<nr_class;i++)
			if(vote[i] > vote[vote_max_idx])				if(vote[i] > vote[vote_max_idx])
				vote_max_idx = i;						vote_max_idx = i;
							      >
		free(kvalue);							free(kvalue);
		free(start);							free(start);
		free(vote);							free(vote);
		return model->label[vote_max_idx];				return model->label[vote_max_idx];
	}								}
}								}

const char *svm_type_table[] =				      |	double svm_predict(const svm_model *model, const svm_node *x)
							      >	{
							      >		int nr_class = model->nr_class;
							      >		double *dec_values;
							      >		if(model->param.svm_type == ONE_CLASS ||
							      >		   model->param.svm_type == EPSILON_SVR ||
							      >		   model->param.svm_type == NU_SVR)
							      >			dec_values = Malloc(double, 1);
							      >		else 
							      >			dec_values = Malloc(double, nr_class*(nr_clas
							      >		double pred_result = svm_predict_values(model, x, dec
							      >		free(dec_values);
							      >		return pred_result;
							      >	}
							      >
							      >	double svm_predict_probability(
							      >		const svm_model *model, const svm_node *x, double *pr
{								{
							      >		if ((model->param.svm_type == C_SVC || model->param.s
							      >		    model->probA!=NULL && model->probB!=NULL)
							      >		{
							      >			int i;
							      >			int nr_class = model->nr_class;
							      >			double *dec_values = Malloc(double, nr_class*
							      >			svm_predict_values(model, x, dec_values);
							      >
							      >			double min_prob=1e-7;
							      >			double **pairwise_prob=Malloc(double *,nr_cla
							      >			for(i=0;i<nr_class;i++)
							      >				pairwise_prob[i]=Malloc(double,nr_cla
							      >			int k=0;
							      >			for(i=0;i<nr_class;i++)
							      >				for(int j=i+1;j<nr_class;j++)
							      >				{
							      >					pairwise_prob[i][j]=min(max(s
							      >					pairwise_prob[j][i]=1-pairwis
							      >					k++;
							      >				}
							      >			multiclass_probability(nr_class,pairwise_prob
							      >
							      >			int prob_max_idx = 0;
							      >			for(i=1;i<nr_class;i++)
							      >				if(prob_estimates[i] > prob_estimates
							      >					prob_max_idx = i;
							      >			for(i=0;i<nr_class;i++)
							      >				free(pairwise_prob[i]);
							      >			free(dec_values);
							      >			free(pairwise_prob);
							      >			return model->label[prob_max_idx];
							      >		}
							      >		else 
							      >			return svm_predict(model, x);
							      >	}

"c_svc","rsvm_lssvm","rsvm_lsvm","rsvm_lssvm2", "rsvm_ssvm",  |	static const char *svm_type_table[] =
							      >	{
							      >		"c_svc","nu_svc","one_class","epsilon_svr","nu_svr",N
							      >	};

const char *kernel_type_table[]=			      |	static const char *kernel_type_table[]=
{								{
	"linear","polynomial","rbf","sigmoid",NULL	      |		"linear","polynomial","rbf","sigmoid","precomputed",N
};								};

int svm_save_model(const char *model_file_name, const svm_mod	int svm_save_model(const char *model_file_name, const svm_mod
{								{
	FILE *fp = fopen(model_file_name,"w");				FILE *fp = fopen(model_file_name,"w");
	if(fp==NULL) return -1;						if(fp==NULL) return -1;

							      >		char *old_locale = setlocale(LC_ALL, NULL);
							      >		if (old_locale) {
							      >			old_locale = strdup(old_locale);
							      >		}
							      >		setlocale(LC_ALL, "C");
							      >
	const svm_parameter& param = model->param;			const svm_parameter& param = model->param;

	fprintf(fp,"svm_type %s\n", svm_type_table[param.svm_		fprintf(fp,"svm_type %s\n", svm_type_table[param.svm_
	fprintf(fp,"kernel_type %s\n", kernel_type_table[para		fprintf(fp,"kernel_type %s\n", kernel_type_table[para

	if(param.kernel_type == POLY)					if(param.kernel_type == POLY)
		fprintf(fp,"degree %g\n", param.degree);      |			fprintf(fp,"degree %d\n", param.degree);

	if(param.kernel_type == POLY || param.kernel_type == 		if(param.kernel_type == POLY || param.kernel_type == 
		fprintf(fp,"gamma %g\n", param.gamma);				fprintf(fp,"gamma %g\n", param.gamma);

	if(param.kernel_type == POLY || param.kernel_type == 		if(param.kernel_type == POLY || param.kernel_type == 
		fprintf(fp,"coef0 %g\n", param.coef0);				fprintf(fp,"coef0 %g\n", param.coef0);

	int nr_class = model->nr_class;					int nr_class = model->nr_class;
	int l = model->l;						int l = model->l;
	fprintf(fp, "nr_class %d\n", nr_class);				fprintf(fp, "nr_class %d\n", nr_class);
	fprintf(fp, "total_sv %d\n",l);					fprintf(fp, "total_sv %d\n",l);
									
	{								{
		fprintf(fp, "rho");						fprintf(fp, "rho");
		for(int i=0;i<nr_class*(nr_class-1)/2;i++)			for(int i=0;i<nr_class*(nr_class-1)/2;i++)
			fprintf(fp," %g",model->rho[i]);				fprintf(fp," %g",model->rho[i]);
		fprintf(fp, "\n");						fprintf(fp, "\n");
	}								}
									
	if(model->label)						if(model->label)
	{								{
		fprintf(fp, "label");						fprintf(fp, "label");
		for(int i=0;i<nr_class;i++)					for(int i=0;i<nr_class;i++)
			fprintf(fp," %d",model->label[i]);				fprintf(fp," %d",model->label[i]);
		fprintf(fp, "\n");						fprintf(fp, "\n");
	}								}

							      >		if(model->probA) // regression has probA only
							      >		{
							      >			fprintf(fp, "probA");
							      >			for(int i=0;i<nr_class*(nr_class-1)/2;i++)
							      >				fprintf(fp," %g",model->probA[i]);
							      >			fprintf(fp, "\n");
							      >		}
							      >		if(model->probB)
							      >		{
							      >			fprintf(fp, "probB");
							      >			for(int i=0;i<nr_class*(nr_class-1)/2;i++)
							      >				fprintf(fp," %g",model->probB[i]);
							      >			fprintf(fp, "\n");
							      >		}
							      >
	if(model->nSV)							if(model->nSV)
	{								{
		fprintf(fp, "nr_sv");						fprintf(fp, "nr_sv");
		for(int i=0;i<nr_class;i++)					for(int i=0;i<nr_class;i++)
			fprintf(fp," %d",model->nSV[i]);				fprintf(fp," %d",model->nSV[i]);
		fprintf(fp, "\n");						fprintf(fp, "\n");
	}								}

	fprintf(fp, "SV\n");						fprintf(fp, "SV\n");
	const double * const *sv_coef = model->sv_coef;			const double * const *sv_coef = model->sv_coef;
	const svm_node * const *SV = model->SV;				const svm_node * const *SV = model->SV;

	for(int i=0;i<l;i++)						for(int i=0;i<l;i++)
	{								{
		for(int j=0;j<nr_class-1;j++)					for(int j=0;j<nr_class-1;j++)
			fprintf(fp, "%.16g ",sv_coef[j][i]);				fprintf(fp, "%.16g ",sv_coef[j][i]);

		const svm_node *p = SV[i];					const svm_node *p = SV[i];
		while(p->index != -1)			      |
		{					      |			if(param.kernel_type == PRECOMPUTED)
			fprintf(fp,"%d:%.8g ",p->index,p->val |				fprintf(fp,"0:%d ",(int)(p->value));
			p++;				      |			else
		}					      |				while(p->index != -1)
							      >				{
							      >					fprintf(fp,"%d:%.8g ",p->inde
							      >					p++;
							      >				}
		fprintf(fp, "\n");						fprintf(fp, "\n");
	}								}

	fclose(fp);					      |		setlocale(LC_ALL, old_locale);
	return 0;					      |		free(old_locale);
							      >
							      >		if (ferror(fp) != 0 || fclose(fp) != 0) return -1;
							      >		else return 0;
}								}

svm_model *svm_load_model(const char *model_file_name)	      |	static char *line = NULL;
							      >	static int max_line_len;
							      >
							      >	static char* readline(FILE *input)
{								{
	FILE *fp = fopen(model_file_name,"rb");		      |		int len;
	if(fp==NULL) return NULL;			      <
							      <
	// read parameters				      <

	svm_model *model = (svm_model *)malloc(sizeof(svm_mod |		if(fgets(line,max_line_len,input) == NULL)
	svm_parameter& param = model->param;		      |			return NULL;
	model->label = NULL;				      |
	model->nSV = NULL;				      |		while(strrchr(line,'\n') == NULL)
							      >		{
							      >			max_line_len *= 2;
							      >			line = (char *) realloc(line,max_line_len);
							      >			len = (int) strlen(line);
							      >			if(fgets(line+len,max_line_len-len,input) == 
							      >				break;
							      >		}
							      >		return line;
							      >	}

							      >	//
							      >	// FSCANF helps to handle fscanf failures.
							      >	// Its do-while block avoids the ambiguity when
							      >	// if (...)
							      >	//    FSCANF();
							      >	// is used
							      >	//
							      >	#define FSCANF(_stream, _format, _var) do{ if (fscanf(_stream
							      >	bool read_model_header(FILE *fp, svm_model* model)
							      >	{
							      >		svm_parameter& param = model->param;
	char cmd[81];							char cmd[81];
	while(1)							while(1)
	{								{
		fscanf(fp,"%80s",cmd);			      |			FSCANF(fp,"%80s",cmd);

		if(strcmp(cmd,"svm_type")==0)					if(strcmp(cmd,"svm_type")==0)
		{								{
			fscanf(fp,"%80s",cmd);		      |				FSCANF(fp,"%80s",cmd);
			int i;								int i;
			for(i=0;svm_type_table[i];i++)					for(i=0;svm_type_table[i];i++)
			{								{
				if(strcmp(svm_type_table[i],c					if(strcmp(svm_type_table[i],c
				{								{
					param.svm_type=i;						param.svm_type=i;
					break;								break;
				}								}
			}								}
			if(svm_type_table[i] == NULL)					if(svm_type_table[i] == NULL)
			{								{
				fprintf(stderr,"unknown svm t					fprintf(stderr,"unknown svm t
				exit(1);		      |					return false;
			}								}
		}								}
		else if(strcmp(cmd,"kernel_type")==0)				else if(strcmp(cmd,"kernel_type")==0)
		{								{		
			fscanf(fp,"%80s",cmd);		      |				FSCANF(fp,"%80s",cmd);
			int i;								int i;
			for(i=0;kernel_type_table[i];i++)				for(i=0;kernel_type_table[i];i++)
			{								{
				if(strcmp(kernel_type_table[i					if(strcmp(kernel_type_table[i
				{								{
					param.kernel_type=i;						param.kernel_type=i;
					break;								break;
				}								}
			}								}
			if(kernel_type_table[i] == NULL)				if(kernel_type_table[i] == NULL)
			{								{
				fprintf(stderr,"unknown kerne |					fprintf(stderr,"unknown kerne
				exit(1);		      |					return false;
			}								}
		}								}
		else if(strcmp(cmd,"degree")==0)				else if(strcmp(cmd,"degree")==0)
			fscanf(fp,"%lf",&param.degree);	      |				FSCANF(fp,"%d",&param.degree);
		else if(strcmp(cmd,"gamma")==0)					else if(strcmp(cmd,"gamma")==0)
			fscanf(fp,"%lf",&param.gamma);	      |				FSCANF(fp,"%lf",&param.gamma);
		else if(strcmp(cmd,"coef0")==0)					else if(strcmp(cmd,"coef0")==0)
			fscanf(fp,"%lf",&param.coef0);	      |				FSCANF(fp,"%lf",&param.coef0);
		else if(strcmp(cmd,"nr_class")==0)				else if(strcmp(cmd,"nr_class")==0)
			fscanf(fp,"%d",&model->nr_class);     |				FSCANF(fp,"%d",&model->nr_class);
		else if(strcmp(cmd,"total_sv")==0)				else if(strcmp(cmd,"total_sv")==0)
			fscanf(fp,"%d",&model->l);	      |				FSCANF(fp,"%d",&model->l);
		else if(strcmp(cmd,"rho")==0)					else if(strcmp(cmd,"rho")==0)
		{								{
			int n = model->nr_class * (model->nr_				int n = model->nr_class * (model->nr_
			model->rho = Malloc(double,n);					model->rho = Malloc(double,n);
			for(int i=0;i<n;i++)						for(int i=0;i<n;i++)
				fscanf(fp,"%lf",&model->rho[i |					FSCANF(fp,"%lf",&model->rho[i
		}								}
		else if(strcmp(cmd,"label")==0)					else if(strcmp(cmd,"label")==0)
		{								{
			int n = model->nr_class;					int n = model->nr_class;
			model->label = Malloc(int,n);					model->label = Malloc(int,n);
			for(int i=0;i<n;i++)						for(int i=0;i<n;i++)
				fscanf(fp,"%d",&model->label[ |					FSCANF(fp,"%d",&model->label[
							      >			}
							      >			else if(strcmp(cmd,"probA")==0)
							      >			{
							      >				int n = model->nr_class * (model->nr_
							      >				model->probA = Malloc(double,n);
							      >				for(int i=0;i<n;i++)
							      >					FSCANF(fp,"%lf",&model->probA
							      >			}
							      >			else if(strcmp(cmd,"probB")==0)
							      >			{
							      >				int n = model->nr_class * (model->nr_
							      >				model->probB = Malloc(double,n);
							      >				for(int i=0;i<n;i++)
							      >					FSCANF(fp,"%lf",&model->probB
		}								}
		else if(strcmp(cmd,"nr_sv")==0)					else if(strcmp(cmd,"nr_sv")==0)
		{								{
			int n = model->nr_class;					int n = model->nr_class;
			model->nSV = Malloc(int,n);					model->nSV = Malloc(int,n);
			for(int i=0;i<n;i++)						for(int i=0;i<n;i++)
				fscanf(fp,"%d",&model->nSV[i] |					FSCANF(fp,"%d",&model->nSV[i]
		}								}
		else if(strcmp(cmd,"SV")==0)					else if(strcmp(cmd,"SV")==0)
		{								{
			while(1)							while(1)
			{								{
				int c = getc(fp);						int c = getc(fp);
				if(c==EOF || c=='\n') break;  |					if(c==EOF || c=='\n') break;
			}								}
			break;								break;
		}								}
		else								else
		{								{
			fprintf(stderr,"unknown text in model |				fprintf(stderr,"unknown text in model
			exit(1);			      |				return false;
		}								}
	}								}

							      >		return true;
							      >
							      >	}
							      >
							      >	svm_model *svm_load_model(const char *model_file_name)
							      >	{
							      >		FILE *fp = fopen(model_file_name,"rb");
							      >		if(fp==NULL) return NULL;
							      >
							      >		char *old_locale = setlocale(LC_ALL, NULL);
							      >		if (old_locale) {
							      >			old_locale = strdup(old_locale);
							      >		}
							      >		setlocale(LC_ALL, "C");
							      >
							      >		// read parameters
							      >
							      >		svm_model *model = Malloc(svm_model,1);
							      >		model->rho = NULL;
							      >		model->probA = NULL;
							      >		model->probB = NULL;
							      >		model->sv_indices = NULL;
							      >		model->label = NULL;
							      >		model->nSV = NULL;
							      >		
							      >		// read header
							      >		if (!read_model_header(fp, model))
							      >		{
							      >			fprintf(stderr, "ERROR: fscanf failed to read
							      >			setlocale(LC_ALL, old_locale);
							      >			free(old_locale);
							      >			free(model->rho);
							      >			free(model->label);
							      >			free(model->nSV);
							      >			free(model);
							      >			return NULL;
							      >		}
							      >		
	// read sv_coef and SV						// read sv_coef and SV

	int elements = 0;						int elements = 0;
	long pos = ftell(fp);						long pos = ftell(fp);

	while(1)					      |		max_line_len = 1024;
							      >		line = Malloc(char,max_line_len);
							      >		char *p,*endptr,*idx,*val;
							      >
							      >		while(readline(fp)!=NULL)
	{								{
		int c = fgetc(fp);			      |			p = strtok(line,":");
		switch(c)				      |			while(1)
		{								{
			case '\n':			      |				p = strtok(NULL,":");
				// count the '-1' element     |				if(p == NULL)
			case ':':			      <
				++elements;		      <
				break;								break;
			case EOF:			      |				++elements;
				goto out;		      <
			default:			      <
				;			      <
		}								}
	}								}
out:							      |		elements += model->l;
							      >
	fseek(fp,pos,SEEK_SET);						fseek(fp,pos,SEEK_SET);

	int m = model->nr_class - 1;					int m = model->nr_class - 1;
	int l = model->l;						int l = model->l;
	model->sv_coef = Malloc(double *,m);				model->sv_coef = Malloc(double *,m);
	int i;								int i;
	for(i=0;i<m;i++)						for(i=0;i<m;i++)
		model->sv_coef[i] = Malloc(double,l);				model->sv_coef[i] = Malloc(double,l);
	model->SV = Malloc(svm_node*,l);				model->SV = Malloc(svm_node*,l);
	svm_node *x_space = Malloc(svm_node,elements);	      |		svm_node *x_space = NULL;
							      >		if(l>0) x_space = Malloc(svm_node,elements);

	int j=0;							int j=0;
	for(i=0;i<l;i++)						for(i=0;i<l;i++)
	{								{
							      >			readline(fp);
		model->SV[i] = &x_space[j];					model->SV[i] = &x_space[j];
		for(int k=0;k<m;k++)			      |
			fscanf(fp,"%lf",&model->sv_coef[k][i] |			p = strtok(line, " \t");
							      >			model->sv_coef[0][i] = strtod(p,&endptr);
							      >			for(int k=1;k<m;k++)
							      >			{
							      >				p = strtok(NULL, " \t");
							      >				model->sv_coef[k][i] = strtod(p,&endp
							      >			}
							      >
		while(1)							while(1)
		{								{
			int c;				      |				idx = strtok(NULL, ":");
			do {				      |				val = strtok(NULL, " \t");
				c = getc(fp);		      |
				if(c=='\n') goto out2;	      |				if(val == NULL)
			} while(isspace(c));		      |					break;
			ungetc(c,fp);			      |				x_space[j].index = (int) strtol(idx,&
			fscanf(fp,"%d:%lf",&(x_space[j].index |				x_space[j].value = strtod(val,&endptr
							      >
			++j;								++j;
		}					      |			}
out2:							      <
		x_space[j++].index = -1;					x_space[j++].index = -1;
	}								}
							      >		free(line);
							      >
							      >		setlocale(LC_ALL, old_locale);
							      >		free(old_locale);

	fclose(fp);					      |		if (ferror(fp) != 0 || fclose(fp) != 0)
							      >			return NULL;

	model->free_sv = 1;	// XXX					model->free_sv = 1;	// XXX
	return model;							return model;
}								}

void svm_destroy_model(svm_model* model)		      |	void svm_free_model_content(svm_model* model_ptr)
							      >	{
							      >		if(model_ptr->free_sv && model_ptr->l > 0 && model_pt
							      >			free((void *)(model_ptr->SV[0]));
							      >		if(model_ptr->sv_coef)
							      >		{
							      >			for(int i=0;i<model_ptr->nr_class-1;i++)
							      >				free(model_ptr->sv_coef[i]);
							      >		}
							      >
							      >		free(model_ptr->SV);
							      >		model_ptr->SV = NULL;
							      >
							      >		free(model_ptr->sv_coef);
							      >		model_ptr->sv_coef = NULL;
							      >
							      >		free(model_ptr->rho);
							      >		model_ptr->rho = NULL;
							      >
							      >		free(model_ptr->label);
							      >		model_ptr->label= NULL;
							      >
							      >		free(model_ptr->probA);
							      >		model_ptr->probA = NULL;
							      >
							      >		free(model_ptr->probB);
							      >		model_ptr->probB= NULL;
							      >
							      >		free(model_ptr->sv_indices);
							      >		model_ptr->sv_indices = NULL;
							      >
							      >		free(model_ptr->nSV);
							      >		model_ptr->nSV = NULL;
							      >	}
							      >
							      >	void svm_free_and_destroy_model(svm_model** model_ptr_ptr)
							      >	{
							      >		if(model_ptr_ptr != NULL && *model_ptr_ptr != NULL)
							      >		{
							      >			svm_free_model_content(*model_ptr_ptr);
							      >			free(*model_ptr_ptr);
							      >			*model_ptr_ptr = NULL;
							      >		}
							      >	}
							      >
							      >	void svm_destroy_param(svm_parameter* param)
							      >	{
							      >		free(param->weight_label);
							      >		free(param->weight);
							      >	}
							      >
							      >	const char *svm_check_parameter(const svm_problem *prob, cons
							      >	{
							      >		// svm_type
							      >
							      >		int svm_type = param->svm_type;
							      >		if(svm_type != C_SVC &&
							      >		   svm_type != NU_SVC &&
							      >		   svm_type != ONE_CLASS &&
							      >		   svm_type != EPSILON_SVR &&
							      >		   svm_type != NU_SVR)
							      >			return "unknown svm type";
							      >		
							      >		// kernel_type, degree
							      >		
							      >		int kernel_type = param->kernel_type;
							      >		if(kernel_type != LINEAR &&
							      >		   kernel_type != POLY &&
							      >		   kernel_type != RBF &&
							      >		   kernel_type != SIGMOID &&
							      >		   kernel_type != PRECOMPUTED)
							      >			return "unknown kernel type";
							      >
							      >		if(param->gamma < 0)
							      >			return "gamma < 0";
							      >
							      >		if(param->degree < 0)
							      >			return "degree of polynomial kernel < 0";
							      >
							      >		// cache_size,eps,C,nu,p,shrinking
							      >
							      >		if(param->cache_size <= 0)
							      >			return "cache_size <= 0";
							      >
							      >		if(param->eps <= 0)
							      >			return "eps <= 0";
							      >
							      >		if(svm_type == C_SVC ||
							      >		   svm_type == EPSILON_SVR ||
							      >		   svm_type == NU_SVR)
							      >			if(param->C <= 0)
							      >				return "C <= 0";
							      >
							      >		if(svm_type == NU_SVC ||
							      >		   svm_type == ONE_CLASS ||
							      >		   svm_type == NU_SVR)
							      >			if(param->nu <= 0 || param->nu > 1)
							      >				return "nu <= 0 or nu > 1";
							      >
							      >		if(svm_type == EPSILON_SVR)
							      >			if(param->p < 0)
							      >				return "p < 0";
							      >
							      >		if(param->shrinking != 0 &&
							      >		   param->shrinking != 1)
							      >			return "shrinking != 0 and shrinking != 1";
							      >
							      >		if(param->probability != 0 &&
							      >		   param->probability != 1)
							      >			return "probability != 0 and probability != 1
							      >
							      >		if(param->probability == 1 &&
							      >		   svm_type == ONE_CLASS)
							      >			return "one-class SVM probability output not 
							      >
							      >
							      >		// check whether nu-svc is feasible
							      >		
							      >		if(svm_type == NU_SVC)
							      >		{
							      >			int l = prob->l;
							      >			int max_nr_class = 16;
							      >			int nr_class = 0;
							      >			int *label = Malloc(int,max_nr_class);
							      >			int *count = Malloc(int,max_nr_class);
							      >
							      >			int i;
							      >			for(i=0;i<l;i++)
							      >			{
							      >				int this_label = (int)prob->y[i];
							      >				int j;
							      >				for(j=0;j<nr_class;j++)
							      >					if(this_label == label[j])
							      >					{
							      >						++count[j];
							      >						break;
							      >					}
							      >				if(j == nr_class)
							      >				{
							      >					if(nr_class == max_nr_class)
							      >					{
							      >						max_nr_class *= 2;
							      >						label = (int *)reallo
							      >						count = (int *)reallo
							      >					}
							      >					label[nr_class] = this_label;
							      >					count[nr_class] = 1;
							      >					++nr_class;
							      >				}
							      >			}
							      >		
							      >			for(i=0;i<nr_class;i++)
							      >			{
							      >				int n1 = count[i];
							      >				for(int j=i+1;j<nr_class;j++)
							      >				{
							      >					int n2 = count[j];
							      >					if(param->nu*(n1+n2)/2 > min(
							      >					{
							      >						free(label);
							      >						free(count);
							      >						return "specified nu 
							      >					}
							      >				}
							      >			}
							      >			free(label);
							      >			free(count);
							      >		}
							      >
							      >		return NULL;
							      >	}
							      >
							      >	int svm_check_probability_model(const svm_model *model)
{								{
	if(model->free_sv)				      |		return ((model->param.svm_type == C_SVC || model->par
		free((void *)(model->SV[0]));		      |			model->probA!=NULL && model->probB!=NULL) ||
	for(int i=0;i<model->nr_class-1;i++)		      |			((model->param.svm_type == EPSILON_SVR || mod
		free(model->sv_coef[i]);		      |			 model->probA!=NULL);
	free(model->SV);				      |	}
	free(model->sv_coef);				      |
	free(model->rho);				      |	void svm_set_print_string_function(void (*print_func)(const c
	free(model->label);				      |	{
	free(model->nSV);				      |		if(print_func == NULL)
	free(model);					      |			svm_print_string = &print_string_stdout;
							      >		else
							      >			svm_print_string = print_func;
}								}
